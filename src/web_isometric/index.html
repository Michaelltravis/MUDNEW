<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RealmsMUD - Isometric View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        /* Top UI Bar */
        #top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 100;
            border-bottom: 1px solid #333;
        }
        
        /* Player Stats */
        #player-stats {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .stat-bar {
            width: 150px;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 1px solid #444;
        }
        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        .stat-bar-hp .stat-bar-fill {
            background: linear-gradient(90deg, #dc2626 0%, #ef4444 100%);
            transition: width 0.3s ease, background 0.5s ease;
        }
        .stat-bar-hp.danger .stat-bar-fill {
            background: linear-gradient(90deg, #7f0000 0%, #cc0000 100%);
            animation: hp-danger-pulse 0.8s ease-in-out infinite alternate;
        }
        .stat-bar-hp.danger {
            border-color: #cc0000;
            box-shadow: 0 0 6px rgba(200,0,0,0.6);
        }
        @keyframes hp-danger-pulse {
            from { opacity: 0.7; }
            to   { opacity: 1.0; }
        }
        .stat-bar-mana .stat-bar-fill {
            background: linear-gradient(90deg, #2563eb 0%, #3b82f6 100%);
        }
        .stat-bar-move .stat-bar-fill {
            background: linear-gradient(90deg, #16a34a 0%, #22c55e 100%);
        }
        .stat-bar-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
        .stat-icon {
            font-size: 18px;
        }
        
        /* Room Info */
        #room-info {
            flex: 1;
            text-align: center;
        }
        #room-name {
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
        }
        #zone-name {
            font-size: 12px;
            color: #888;
        }
        
        /* Combat Indicator */
        #combat-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(220, 38, 38, 0.3);
            border: 1px solid #dc2626;
            border-radius: 20px;
            animation: combat-pulse 1s infinite;
        }
        #combat-indicator.active {
            display: flex;
        }
        @keyframes combat-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        #combat-indicator span {
            color: #ff6b6b;
            font-weight: bold;
            font-size: 13px;
        }
        
        /* Hotkey Bar */
        #hotkey-bar {
            position: fixed;
            bottom: 220px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #444;
            cursor: grab;
            user-select: none;
        }
        #hotkey-bar.dragging { cursor: grabbing; }
        #hotkey-bar::before {
            content: '‚†ø';
            color: #555;
            font-size: 16px;
            margin-right: 6px;
            cursor: grab;
            align-self: center;
        }
        .hotkey-slot {
            width: 45px;
            height: 45px;
            background: #222;
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }
        .hotkey-slot:hover {
            border-color: #ffd700;
            background: #333;
        }
        .hotkey-slot.on-cooldown {
            opacity: 0.5;
        }
        .hotkey-slot .cooldown {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            background: rgba(0,0,0,0.55);
            border-radius: 6px;
        }
        .hotkey-slot.on-cooldown .cooldown { display: flex; }
        .hotkey-slot .key-num {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: #666;
        }
        .hotkey-slot .skill-icon {
            font-size: 20px;
        }
        .hotkey-slot .skill-name {
            font-size: 8px;
            color: #aaa;
            margin-top: 2px;
        }
        
        /* Minimap */
        #minimap {
            position: fixed;
            top: 70px;
            right: 10px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #444;
            border-radius: 8px;
            z-index: 100;
            overflow: hidden;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
        #minimap-label {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #666;
        }
        #minimap-toggle {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #444;
            color: #aaa;
            font-size: 12px;
            border-radius: 6px;
            padding: 2px 4px;
            cursor: pointer;
        }
        #minimap.minimized {
            width: 52px;
            height: 52px;
            opacity: 0.75;
        }
        #minimap.minimized #minimap-label { display: none; }
        #minimap.minimized #minimap-canvas { opacity: 0.0; }
        
        /* Text output panel */
        #text-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 600px;
            height: 200px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #444;
            border-radius: 8px 8px 0 0;
            display: flex;
            flex-direction: column;
            z-index: 100;
            min-width: 300px;
            min-height: 120px;
        }
        #text-panel-header {
            display: flex;
            align-items: center;
            padding: 4px 10px;
            background: rgba(255,255,255,0.05);
            border-bottom: 1px solid #333;
            cursor: grab;
            border-radius: 8px 8px 0 0;
            user-select: none;
            font-size: 11px;
            color: #555;
            gap: 6px;
        }
        #text-panel-header:active { cursor: grabbing; }
        #text-panel-header span { flex: 1; }
        #text-panel-resize {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 14px;
            height: 14px;
            cursor: se-resize;
            opacity: 0.3;
            background: linear-gradient(135deg, transparent 50%, #888 50%);
        }
        #text-output {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #ccc;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        #text-output .ansi-red { color: #ff6b6b; }
        #text-output .ansi-green { color: #69db7c; }
        #text-output .ansi-yellow { color: #ffd43b; }
        #text-output .ansi-blue { color: #74c0fc; }
        #text-output .ansi-magenta { color: #da77f2; }
        #text-output .ansi-cyan { color: #66d9e8; }
        #text-output .ansi-white { color: #fff; }
        #text-output .ansi-bold { font-weight: bold; }
        #command-line {
            display: flex;
            border-top: 1px solid #333;
        }
        #command-input {
            flex: 1;
            border: none;
            background: #111;
            color: #fff;
            padding: 10px 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            outline: none;
        }
        #command-input::placeholder {
            color: #555;
        }
        #send-btn {
            padding: 10px 20px;
            background: #ffd700;
            color: #000;
            border: none;
            font-weight: bold;
            cursor: pointer;
        }
        #send-btn:hover {
            background: #ffed4a;
        }
        
        /* Login Panel */
        #login-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid #555;
            z-index: 200;
            min-width: 320px;
        }
        #login-panel h2 {
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
        }
        #login-panel input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #444;
            border-radius: 6px;
            background: #222;
            color: #fff;
            font-size: 16px;
        }
        #login-panel button {
            width: 100%;
            padding: 12px;
            background: #ffd700;
            color: #000;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
        }
        #login-panel button:hover {
            background: #ffed4a;
        }
        #login-panel .info {
            color: #666;
            font-size: 12px;
            text-align: center;
            margin-top: 15px;
        }
        
        /* Tooltips */
        #tooltip {
            position: fixed;
            background: rgba(0,0,0,0.95);
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            z-index: 150;
            display: none;
            border: 1px solid #555;
            max-width: 250px;
        }
        #tooltip .mob-name {
            color: #ffd700;
            font-weight: bold;
        }
        #tooltip .mob-level {
            color: #888;
            font-size: 11px;
        }
        #tooltip .mob-hp {
            margin-top: 5px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        #tooltip .mob-hp-fill {
            height: 100%;
            background: #ef4444;
        }
        #tooltip .hostile-tag {
            color: #ff6b6b;
            font-size: 10px;
            margin-left: 5px;
        }
        
        /* Zoom Controls */
        #zoom-controls {
            position: fixed;
            right: 10px;
            top: 260px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .zoom-btn:hover {
            background: rgba(50,50,50,0.9);
            border-color: #666;
        }
        
        /* Path indicator */
        .path-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
            border-radius: 50%;
            animation: path-pulse 0.5s infinite;
        }
        @keyframes path-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }
        
        /* Controls help */
        #controls-help {
            position: fixed;
            bottom: 210px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
            z-index: 100;
        }
        #controls-help div {
            margin: 3px 0;
        }
        #controls-help kbd {
            background: #333;
            padding: 2px 5px;
            border-radius: 3px;
            color: #aaa;
        }
        
        /* Combat Portrait */
        #combat-portrait {
            position: fixed;
            top: 70px;
            left: 10px;
            z-index: 110;
            animation: portrait-slide-in 0.3s ease;
        }
        @keyframes portrait-slide-in {
            from { transform: translateX(-120%); opacity: 0; }
            to   { transform: translateX(0);    opacity: 1; }
        }
        #portrait-frame {
            position: relative;
            background: linear-gradient(160deg, #1a0a0a 0%, #0d0010 100%);
            border: 2px solid #aa2222;
            border-radius: 10px;
            padding: 12px;
            width: 160px;
            box-shadow: 0 0 20px rgba(180,0,0,0.4), inset 0 0 10px rgba(0,0,0,0.5);
        }
        #portrait-frame.boss-frame {
            border-color: #cc00ff;
            box-shadow: 0 0 25px rgba(180,0,255,0.5), inset 0 0 10px rgba(0,0,0,0.5);
        }
        #portrait-name {
            color: #ff8888;
            font-weight: bold;
            font-size: 13px;
            text-align: center;
            margin-bottom: 3px;
            text-shadow: 0 0 8px rgba(255,100,100,0.6);
        }
        #portrait-frame.boss-frame #portrait-name {
            color: #dd88ff;
            text-shadow: 0 0 8px rgba(200,100,255,0.8);
        }
        #portrait-level {
            color: #888;
            font-size: 11px;
            text-align: center;
            margin-bottom: 8px;
        }
        #portrait-img {
            width: 136px;
            height: 136px;
            object-fit: contain;
            display: block;
            margin: 0 auto 8px;
            image-rendering: pixelated;
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            transition: filter 0.4s ease;
        }
        #portrait-empty {
            position: absolute;
            top: 84px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
            letter-spacing: 0.5px;
            display: none;
        }
        #portrait-flags {
            margin-top: 6px;
            font-size: 10px;
            color: #aaa;
            text-align: center;
        }
        #portrait-flags .flag {
            display: inline-block;
            margin: 2px 3px 0;
            padding: 2px 5px;
            border-radius: 6px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #portrait-grid {
            margin-top: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(46px, 1fr));
            gap: 6px;
        }
        .portrait-tile {
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 6px;
            padding: 4px;
            cursor: pointer;
            transition: transform 0.15s, border-color 0.15s;
        }
        .portrait-tile:hover { border-color: #ffd700; transform: translateY(-2px); }
        .portrait-tile.active { border-color: #ff4444; box-shadow: 0 0 6px rgba(255,80,80,0.6); }
        .portrait-tile img {
            width: 100%;
            height: 42px;
            object-fit: contain;
            image-rendering: pixelated;
            border-radius: 4px;
            display: block;
            background: rgba(0,0,0,0.4);
        }
        .portrait-tile .lvl { font-size: 9px; color: #bbb; text-align: center; margin-top: 2px; }
        .portrait-tile .hp { height: 4px; background: #222; border-radius: 3px; margin-top: 3px; overflow: hidden; }
        .portrait-tile .hp > div { height: 100%; background: linear-gradient(90deg,#cc2222,#ff4444); }
        .portrait-more { font-size: 10px; color: #aaa; text-align: center; padding-top: 10px; }
        #portrait-img.dead {
            filter: grayscale(100%) brightness(0.4);
        }
        #portrait-dead-overlay {
            display: none;
            position: absolute;
            top: 36px;
            left: 50%;
            transform: translateX(-50%);
            width: 136px;
            height: 136px;
            align-items: center;
            justify-content: center;
            font-size: 52px;
            pointer-events: none;
            z-index: 2;
        }
        #portrait-dead-overlay.visible {
            display: flex;
        }
        #portrait-hp-wrap {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }
        #portrait-hp-bar {
            flex: 1;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #555;
        }
        #portrait-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #cc2222, #ff4444);
            transition: width 0.4s ease;
        }
        #portrait-hp-label {
            font-size: 10px;
            color: #aaa;
            white-space: nowrap;
        }
        #portrait-type {
            text-align: center;
            font-size: 10px;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hidden { display: none !important; }

        /* ============================================ */
        /* CHARACTER SHEET PANEL                        */
        /* ============================================ */
        #char-sheet {
            position: fixed;
            right: 340px;
            top: 20px;
            width: 320px;
            background: rgba(12,4,4,0.97);
            border: 1px solid #aa2222;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #ccc;
            z-index: 100;
            box-shadow: 0 0 24px rgba(180,0,0,0.35);
            display: flex;
            flex-direction: column;
            max-height: 600px;
            cursor: default;
            resize: both;
            overflow: auto;
            min-width: 260px;
            min-height: 220px;
        }
        #cs-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px 6px;
            border-bottom: 1px solid #3a1010;
            flex-shrink: 0;
            cursor: grab;
            user-select: none;
        }
        #cs-header:active { cursor: grabbing; }
        #cs-portrait {
            width: 36px;
            height: 36px;
            object-fit: contain;
            image-rendering: pixelated;
            background: rgba(0,0,0,0.4);
            border-radius: 4px;
            border: 1px solid #551111;
            flex-shrink: 0;
        }
        #cs-name {
            flex: 1;
            font-weight: bold;
            color: #ff8888;
            font-size: 16px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #cs-class-badge {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #cs-close {
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 0 2px;
            line-height: 1;
            flex-shrink: 0;
        }
        #cs-close:hover { color: #ff4444; }
        #cs-tabs {
            display: flex;
            border-bottom: 1px solid #3a1010;
            flex-shrink: 0;
        }
        .cs-tab {
            flex: 1;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: #666;
            font-size: 13px;
            padding: 8px 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: color 0.2s, border-color 0.2s;
        }
        .cs-tab:hover { color: #aaa; }
        .cs-tab.active { color: #ff8888; border-bottom-color: #aa2222; }
        #cs-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            min-height: 0;
        }
        #cs-content::-webkit-scrollbar { width: 4px; }
        #cs-content::-webkit-scrollbar-track { background: transparent; }
        #cs-content::-webkit-scrollbar-thumb { background: #441111; border-radius: 2px; }
        .cs-stat-bars { margin-bottom: 10px; }
        .cs-bar-row { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
        .cs-bar-label { width: 44px; color: #777; font-size: 12px; text-transform: uppercase; flex-shrink: 0; }
        .cs-bar-wrap { flex: 1; height: 8px; background: #1a0808; border-radius: 4px; overflow: hidden; }
        .cs-bar-fill { height: 100%; border-radius: 4px; transition: width 0.4s; }
        .cs-bar-val { font-size: 12px; color: #888; white-space: nowrap; width: 64px; text-align: right; flex-shrink: 0; }
        .cs-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px 12px; margin-bottom: 12px; }
        .cs-stat-cell { display: flex; justify-content: space-between; align-items: center; }
        .cs-stat-name { color: #666; font-size: 12px; text-transform: uppercase; }
        .cs-stat-val { color: #e0c090; font-size: 14px; font-weight: bold; }
        .cs-eq-item { margin-bottom: 10px; }
        .cs-eq-slot { color: #555; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
        .cs-eq-name { color: #ddd; font-size: 13px; margin: 2px 0; }
        .cs-eq-affects { color: #88aaff; font-size: 12px; }
        .cs-inv-item { color: #bbb; font-size: 13px; padding: 3px 0; border-bottom: 1px solid #1a0808; }
        .cs-inv-type { color: #555; font-size: 11px; float: right; }
        .cs-skill-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px 10px; }
        .cs-skill-row { display: flex; justify-content: space-between; align-items: center; }
        .cs-skill-name { color: #aaa; font-size: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .cs-skill-val { color: #88ff88; font-size: 12px; flex-shrink: 0; margin-left: 4px; }
        .cs-section-title { color: #aa6622; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin: 10px 0 5px; border-bottom: 1px solid #2a1010; padding-bottom: 3px; }
        .cs-empty { color: #444; font-style: italic; font-size: 13px; text-align: center; padding: 24px 0; }

        /* ============================================ */
        /* MAP VIEW CONTROLS + WORLD MAP                */
        /* ============================================ */
        #map-view-controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            z-index: 50;
            background: rgba(10,3,3,0.85);
            border: 1px solid #3a1010;
            border-radius: 8px;
            padding: 3px;
        }
        .map-view-btn {
            background: none;
            border: none;
            color: #666;
            font-size: 11px;
            padding: 4px 10px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }
        .map-view-btn:hover { color: #aaa; background: rgba(255,255,255,0.05); }
        .map-view-btn.active { color: #ff8888; background: rgba(170,34,34,0.25); }
        #world-map-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.88);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        #world-map-overlay.hidden { display: none !important; }
        #world-map-header {
            color: #ff8888;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        #world-map-canvas {
            border: 1px solid #3a1010;
            border-radius: 4px;
            cursor: pointer;
        }
        #world-map-legend {
            display: flex;
            gap: 12px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: #666;
        }
        #world-map-tooltip {
            position: fixed;
            background: rgba(15,5,5,0.95);
            border: 1px solid #aa2222;
            color: #ccc;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 6px 10px;
            border-radius: 6px;
            pointer-events: none;
            z-index: 250;
            white-space: nowrap;
            display: none;
        }
        #world-map-close {
            margin-top: 10px;
            background: rgba(170,34,34,0.2);
            border: 1px solid #aa2222;
            color: #ff8888;
            padding: 6px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        #world-map-close:hover { background: rgba(170,34,34,0.4); }

        /* ============================================ */
        /* VFX SYSTEMS                                  */
        /* ============================================ */

        /* Screen Flash Overlay */
        #screen-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
        }

        /* Boss Health Bar */
        #boss-bar {
            position: fixed;
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            width: 420px;
            z-index: 110;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        #boss-bar-title {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ff4444;
            font-size: 15px;
            font-weight: bold;
            text-shadow: 0 0 12px #ff0000, 0 0 24px #ff0000;
            letter-spacing: 1px;
        }
        .boss-skull {
            font-size: 20px;
            animation: boss-skull-pulse 0.9s infinite alternate;
            display: inline-block;
        }
        @keyframes boss-skull-pulse {
            from { transform: scale(1) rotate(-5deg); }
            to   { transform: scale(1.2) rotate(5deg); }
        }
        #boss-bar-track {
            width: 100%;
            height: 20px;
            background: #1a0000;
            border: 2px solid #660000;
            border-radius: 10px;
            overflow: hidden;
            animation: boss-glow-pulse 1.4s infinite alternate;
        }
        @keyframes boss-glow-pulse {
            from { box-shadow: 0 0 8px #ff000066, inset 0 0 4px #ff000033; }
            to   { box-shadow: 0 0 22px #ff0000bb, inset 0 0 8px #ff000055; }
        }
        #boss-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #770000 0%, #dd1111 55%, #ff5555 100%);
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        /* Combat Log Panel */
        #combat-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 340px;
            height: 240px;
            background: rgba(12, 0, 0, 0.9);
            border: 2px solid #551111;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            z-index: 110;
            min-width: 260px;
            min-height: 120px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        #combat-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            background: linear-gradient(180deg, #330808 0%, #220404 100%);
            border-bottom: 1px solid #551111;
            cursor: grab;
            user-select: none;
            color: #ff8888;
            font-weight: bold;
            font-size: 11px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        #combat-panel-header:active { cursor: grabbing; }
        #combat-log-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            scrollbar-width: thin;
            scrollbar-color: #662222 #1a0505;
            color: #ccc;
        }
        #combat-log-content::-webkit-scrollbar { width: 6px; }
        #combat-log-content::-webkit-scrollbar-track { background: #1a0505; }
        #combat-log-content::-webkit-scrollbar-thumb { background: #662222; border-radius: 3px; }

        #combat-panel-resize {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            cursor: se-resize;
            background: linear-gradient(135deg, transparent 50%, #aa4444 50%);
            opacity: 0.6;
        }
        #combat-panel-resize:hover { opacity: 1; }

        .combat-log-line {
            background: rgba(0,0,0,0.4);
            border-left: 2px solid #666;
            padding: 3px 8px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            border-radius: 0 4px 4px 0;
            margin-bottom: 1px;
            line-height: 1.3;
        }
        .combat-log-line.attack   { border-color: #ffd700; color: #ffd700; }
        .combat-log-line.damage   { border-color: #ff4444; color: #ffaaaa; }
        .combat-log-line.heal     { border-color: #44ff88; color: #88ffbb; }
        .combat-log-line.death    { border-color: #777777; color: #999999; }
        .combat-log-line.critical {
            border-color: #ff2200;
            border-width: 3px;
            color: #ff6622;
            font-size: 14px;
            font-weight: bold;
            background: rgba(80,10,0,0.85);
            text-shadow: 0 0 8px rgba(255,80,0,0.9);
            padding: 6px 10px;
            animation: combat-line-crit 0.25s ease-out;
        }
        .combat-log-line.kill {
            border-color: #ffd700;
            border-width: 3px;
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
            background: rgba(40,30,0,0.9);
            text-shadow: 0 0 10px rgba(255,215,0,0.8);
            padding: 6px 10px;
            animation: combat-line-kill 0.3s ease-out;
        }
        @keyframes combat-line-slide {
            from { transform: translateX(24px); opacity: 0; }
            to   { transform: translateX(0);    opacity: 1; }
        }
        @keyframes combat-line-crit {
            0%   { transform: translateX(24px) scale(1.15); opacity: 0; }
            60%  { transform: translateX(-4px) scale(1.08); opacity: 1; }
            100% { transform: translateX(0) scale(1); opacity: 1; }
        }
        @keyframes combat-line-kill {
            0%   { transform: translateX(24px) scale(1.1); opacity: 0; }
            100% { transform: translateX(0) scale(1); opacity: 1; }
        }

        /* Low HP vignette */
        #danger-vignette {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 95;
            opacity: 0;
            background: radial-gradient(ellipse at center,
                transparent 45%,
                rgba(180,0,0,0.18) 65%,
                rgba(220,0,0,0.55) 100%);
            transition: opacity 0.6s ease;
        }
        #danger-vignette.active {
            opacity: 1;
            animation: vignette-pulse 1.1s ease-in-out infinite alternate;
        }
        @keyframes vignette-pulse {
            from { opacity: 0.6; }
            to   { opacity: 1.0; }
        }

        /* Status effects panel */
        #status-effects {
            position: fixed;
            top: 70px;
            left: 20px;
            z-index: 120;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-width: 280px;
        }
        .effect-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            background: rgba(0,0,0,0.65);
            border: 1px solid rgba(255,255,255,0.12);
            color: #ddd;
            white-space: nowrap;
        }
        .effect-pill.buff { border-color: rgba(80,220,140,0.6); color: #c7ffde; }
        .effect-pill.debuff { border-color: rgba(255,80,80,0.6); color: #ffbdbd; }
        .effect-pill .dur { color: #aaa; font-size: 10px; }

        /* Combat log extra types */
        .combat-log-line.resist {
            border-color: #66ccff;
            color: #aaddff;
            font-size: 12px;
        }
        .combat-log-line.vuln {
            border-color: #ff66cc;
            color: #ffb3e6;
            font-size: 12px;
        }

        /* Level Up Banner */
        #levelup-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 52px;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 20px #ffaa00, 0 0 50px #ff8800, 0 0 80px #ff6600;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            display: none;
            letter-spacing: 6px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Top Bar -->
    <div id="top-bar" class="hidden">
        <div id="player-stats">
            <div class="stat-bar stat-bar-hp">
                <div class="stat-bar-fill" id="hp-fill" style="width: 100%"></div>
                <div class="stat-bar-label"><span id="hp-text">100/100</span> HP</div>
            </div>
            <div class="stat-bar stat-bar-mana">
                <div class="stat-bar-fill" id="mana-fill" style="width: 100%"></div>
                <div class="stat-bar-label"><span id="mana-text">100/100</span> MP</div>
            </div>
            <div class="stat-bar stat-bar-move">
                <div class="stat-bar-fill" id="move-fill" style="width: 100%"></div>
                <div class="stat-bar-label"><span id="move-text">100/100</span> MV</div>
            </div>
        </div>
        
        <div id="room-info">
            <div id="room-name">Loading...</div>
            <div id="zone-name"></div>
        </div>
        
        <div id="combat-indicator">
            <span>‚öîÔ∏è COMBAT</span>
        </div>
    </div>
    
    <!-- Minimap -->
    <div id="minimap" class="hidden">
        <canvas id="minimap-canvas"></canvas>
        <div id="minimap-label">Zone Map</div>
        <button id="minimap-toggle" onclick="toggleMinimap()">üó∫Ô∏è</button>
    </div>
    
    <!-- Zoom Controls -->
    <div id="zoom-controls" class="hidden">
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
        <button class="zoom-btn" onclick="resetCamera()">‚ü≤</button>
    </div>
    
    <!-- Hotkey Bar -->
    <div id="hotkey-bar" class="hidden">
        <div class="hotkey-slot" data-slot="1" onclick="useHotkey(1)">
            <span class="key-num">1</span>
            <span class="skill-icon">‚öîÔ∏è</span>
            <span class="skill-name">Attack</span>
        </div>
        <div class="hotkey-slot" data-slot="2" onclick="useHotkey(2)">
            <span class="key-num">2</span>
            <span class="skill-icon">üõ°Ô∏è</span>
            <span class="skill-name">Defend</span>
        </div>
        <div class="hotkey-slot" data-slot="3" onclick="useHotkey(3)">
            <span class="key-num">3</span>
            <span class="skill-icon">üíä</span>
            <span class="skill-name">Heal</span>
        </div>
        <div class="hotkey-slot" data-slot="4" onclick="useHotkey(4)">
            <span class="key-num">4</span>
            <span class="skill-icon">üî•</span>
            <span class="skill-name">Skill 4</span>
        </div>
        <div class="hotkey-slot" data-slot="5" onclick="useHotkey(5)">
            <span class="key-num">5</span>
            <span class="skill-icon">‚ùÑÔ∏è</span>
            <span class="skill-name">Skill 5</span>
        </div>
        <div class="hotkey-slot" data-slot="6" onclick="useHotkey(6)">
            <span class="key-num">6</span>
            <span class="skill-icon">‚ö°</span>
            <span class="skill-name">Skill 6</span>
        </div>
        <div class="hotkey-slot" data-slot="7" onclick="useHotkey(7)">
            <span class="key-num">7</span>
            <span class="skill-icon">üß™</span>
            <span class="skill-name">Potion</span>
        </div>
        <div class="hotkey-slot" data-slot="8" onclick="useHotkey(8)">
            <span class="key-num">8</span>
            <span class="skill-icon">üìú</span>
            <span class="skill-name">Scroll</span>
        </div>
        <div class="hotkey-slot" data-slot="9" onclick="useHotkey(9)">
            <span class="key-num">9</span>
            <span class="skill-icon">üèÉ</span>
            <span class="skill-name">Flee</span>
        </div>
    </div>
    
    <!-- Controls Help -->
    <div id="controls-help" class="hidden">
        <div><kbd>Scroll</kbd> Zoom</div>
        <div><kbd>Right-drag</kbd> Rotate</div>
        <div><kbd>Click</kbd> Walk to room</div>
        <div><kbd>1-9</kbd> Hotkeys</div>
    </div>
    
    <!-- Text Panel -->
    <div id="text-panel" class="hidden">
        <div id="text-panel-header">
            <span>‚†ø MUD Output</span>
            <small style="color:#444">drag to move</small>
        </div>
        <div id="text-output"></div>
        <div id="command-line">
            <input type="text" id="command-input" placeholder="Enter command...">
            <button id="send-btn" onclick="sendCurrentCommand()">Send</button>
        </div>
        <div id="text-panel-resize"></div>
    </div>
    
    <!-- Login Panel -->
    <div id="login-panel">
        <h2>üó∫Ô∏è RealmsMUD</h2>
        <input type="text" id="account-name" placeholder="Account name" autofocus>
        <input type="password" id="account-password" placeholder="Password">
        <button onclick="connect()">Enter World</button>
        <div class="info">Isometric 3D Client</div>
    </div>
    
    <!-- Map View Controls -->
    <div id="map-view-controls" class="hidden">
        <button class="map-view-btn active" data-mode="zone" onclick="setMapViewMode('zone')">Zone</button>
        <button class="map-view-btn" data-mode="full" onclick="setMapViewMode('full')">Full</button>
        <button class="map-view-btn" data-mode="world" onclick="openWorldMap()">World</button>
    </div>

    <!-- World Map Overlay -->
    <div id="world-map-overlay" class="hidden">
        <div id="world-map-header">‚öî Realms ‚Äî World Map ‚öî</div>
        <canvas id="world-map-canvas" width="900" height="620"></canvas>
        <div id="world-map-legend">
            <span>‚óè Lv 1-10</span><span>‚óè Lv 11-20</span><span>‚óè Lv 21-35</span><span>‚óè Lv 36-50</span><span>‚óè Lv 51-60</span>
            <span style="margin-left:10px">Click zone to view ¬∑ Esc to close</span>
        </div>
        <button id="world-map-close" onclick="closeWorldMap()">Close World Map</button>
    </div>
    <div id="world-map-tooltip"></div>

    <!-- Character Sheet Panel -->
    <div id="char-sheet" class="hidden">
        <div id="cs-header">
            <img id="cs-portrait" src="" alt="">
            <div style="flex:1;min-width:0">
                <div id="cs-name">‚Äî</div>
                <div id="cs-class-badge">‚Äî</div>
            </div>
            <button id="cs-close" onclick="toggleCharSheet()" title="Close">‚úï</button>
        </div>
        <div id="cs-tabs">
            <button class="cs-tab active" onclick="switchCSTab('stats',this)">Stats</button>
            <button class="cs-tab" onclick="switchCSTab('equip',this)">Equip</button>
            <button class="cs-tab" onclick="switchCSTab('inv',this)">Items</button>
            <button class="cs-tab" onclick="switchCSTab('skills',this)">Skills</button>
        </div>
        <div id="cs-content"></div>
    </div>

    <!-- Combat Portrait -->
    <div id="combat-portrait" class="hidden">
        <div id="portrait-frame">
            <div id="portrait-name"></div>
            <div id="portrait-level"></div>
            <img id="portrait-img" src="" alt="">
            <div id="portrait-empty">No target</div>
            <div id="portrait-dead-overlay">üíÄ</div>
            <div id="portrait-hp-wrap">
                <div id="portrait-hp-bar"><div id="portrait-hp-fill"></div></div>
                <div id="portrait-hp-label"></div>
            </div>
            <div id="portrait-type"></div>
            <div id="portrait-flags"></div>
            <div id="portrait-grid"></div>
        </div>
    </div>

    <!-- Tooltip -->
    <div id="tooltip"></div>

    <!-- VFX Overlays -->
    <div id="screen-flash"></div>
    <div id="danger-vignette"></div>
    <div id="status-effects"></div>

    <div id="boss-bar">
        <div id="boss-bar-title">
            <span class="boss-skull">üíÄ</span>
            <span id="boss-bar-name">Boss</span>
            <span class="boss-skull">üíÄ</span>
        </div>
        <div id="boss-bar-track">
            <div id="boss-bar-fill" style="width: 100%"></div>
        </div>
    </div>

    <!-- Combat Log Panel -->
    <div id="combat-panel" class="hidden">
        <div id="combat-panel-header">
            <span>‚öî COMBAT LOG</span>
            <small style="color:#aaa">drag to move</small>
        </div>
        <div id="combat-log-content"></div>
        <div id="combat-panel-resize"></div>
    </div>

    <div id="levelup-banner">‚ú¶ LEVEL UP! ‚ú¶</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // RealmsMUD Isometric Client v2
        // ============================================
        
        const CONFIG = {
            TILE_SIZE: 2,
            TILE_HEIGHT: 0.5,
            TILE_GAP: 0.3,
            CAMERA_DISTANCE: 50,
            LERP_SPEED: 0.08,
            MIN_ZOOM: 20,
            MAX_ZOOM: 100,
            MUD_PORT: 4003,
            MAP_PORT: 4001,
        };
        
        // Sector colors: top, side, emissive (glow), roughness, metalness, edgeColor
        const SECTOR_COLORS = {
            'city':          { top: 0x9aabb8, side: 0x6a7d8c, emissive: 0x000000, roughness: 0.9, metalness: 0.05, edge: 0xaabbcc },
            'inside':        { top: 0xb0a0c0, side: 0x7a6a8a, emissive: 0x110011, roughness: 0.85, metalness: 0.0,  edge: 0xccaadd },
            'forest':        { top: 0x2a9940, side: 0x156625, emissive: 0x051408, roughness: 1.0,  metalness: 0.0,  edge: 0x44ff66 },
            'field':         { top: 0xd4c060, side: 0xaa9940, emissive: 0x080600, roughness: 1.0,  metalness: 0.0,  edge: 0xddcc77 },
            'water_swim':    { top: 0x2288ee, side: 0x1155aa, emissive: 0x001133, roughness: 0.1,  metalness: 0.3,  edge: 0x44aaff },
            'water_noswim':  { top: 0x1166bb, side: 0x0d3d88, emissive: 0x000d22, roughness: 0.1,  metalness: 0.3,  edge: 0x2288ee },
            'underwater':    { top: 0x0d44bb, side: 0x082288, emissive: 0x000d33, roughness: 0.05, metalness: 0.4,  edge: 0x1166ff },
            'mountain':      { top: 0x8a7c6a, side: 0x655545, emissive: 0x000000, roughness: 0.95, metalness: 0.1,  edge: 0xaa9977 },
            'hills':         { top: 0x88aa66, side: 0x5d7744, emissive: 0x020400, roughness: 0.95, metalness: 0.0,  edge: 0x99bb77 },
            'dungeon':       { top: 0x4a2255, side: 0x2d1138, emissive: 0x110022, roughness: 0.8,  metalness: 0.15, edge: 0x8833bb },
            'desert':        { top: 0xe0c878, side: 0xbbaa55, emissive: 0x100800, roughness: 1.0,  metalness: 0.0,  edge: 0xeedd99 },
            'swamp':         { top: 0x4a6638, side: 0x2e4020, emissive: 0x050a02, roughness: 1.0,  metalness: 0.0,  edge: 0x6a8844 },
            'road':          { top: 0x8a7855, side: 0x665533, emissive: 0x000000, roughness: 0.9,  metalness: 0.05, edge: 0xaa9966 },
            'sewer':         { top: 0x3a5538, side: 0x1e3320, emissive: 0x041008, roughness: 0.85, metalness: 0.1,  edge: 0x446644 },
            'cave':          { top: 0x5a4030, side: 0x362211, emissive: 0x080200, roughness: 0.95, metalness: 0.05, edge: 0x886644 },
            'tunnel':        { top: 0x3a2828, side: 0x1e1111, emissive: 0x080000, roughness: 0.95, metalness: 0.05, edge: 0x664444 },
            'default':       { top: 0x6a6888, side: 0x484560, emissive: 0x000000, roughness: 0.85, metalness: 0.05, edge: 0x8888aa },
        };
        
        // State
        let scene, camera, renderer, raycaster, mouse;
        let mudWs = null, mapWs = null;
        let playerName = '';
        let currentRoom = null;
        let currentTargetName = null;
        let roomMeshes = new Map();
        let connectorMeshes = [];
        let pathMeshes = [];
        let playerMarker = null;
        let targetCameraPos = new THREE.Vector3();
        let cameraInitialized = false;
        let roomData = new Map();
        let allRoomsData = [];
        let isLoggedIn = false;
        let inCombat = false;
        let commandHistory = [];
        let historyIndex = -1;
        
        // Camera rotation
        let cameraAngle = Math.PI / 4; // 45 degrees
        let cameraPitch = Math.PI / 6; // 30 degrees
        let cameraDistance = CONFIG.CAMERA_DISTANCE;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        
        // Pathfinding
        let currentPath = [];
        let isAutoWalking = false;
        
        // Player stats
        let playerStats = { hp: 100, maxHp: 100, mana: 100, maxMana: 100, move: 100, maxMove: 100 };
        
        // Hotkey bindings
        const hotkeys = {
            1: 'kill',
            2: 'defend',
            3: 'heal',
            4: '',
            5: '',
            6: '',
            7: 'quaff heal',
            8: 'recite recall',
            9: 'flee'
        };
        
        // ============================================
        // VFX SYSTEMS
        // ============================================

        // --- Screen Flash ---
        function screenFlash(color, durationMs) {
            const el = document.getElementById('screen-flash');
            el.style.transition = 'none';
            el.style.background = color;
            el.style.opacity = '1';
            // Force reflow so the instant-on is visible, then fade out
            void el.offsetWidth;
            el.style.transition = `opacity ${durationMs}ms ease-out`;
            el.style.opacity = '0';
        }

        // --- Camera Shake ---
        let _shakeEndTime = 0;
        let _shakeIntensity = 0;

        function cameraShake(intensity, durationMs) {
            _shakeIntensity = intensity;
            _shakeEndTime = Date.now() + durationMs;
        }

        function _applyCameraShake() {
            if (Date.now() >= _shakeEndTime) return;
            const remaining = (_shakeEndTime - Date.now()) / 400;
            const amt = _shakeIntensity * Math.min(remaining, 1);
            camera.position.x += (Math.random() - 0.5) * amt;
            camera.position.y += (Math.random() - 0.5) * amt * 0.5;
            camera.position.z += (Math.random() - 0.5) * amt;
        }

        // --- Ambient Particle System ---
        const AMBIENT_COUNT = 50;
        let _ambientPoints = null;
        let _ambientVelocities = [];
        let _ambientSector = '';

        const _PARTICLE_CFG = {
            forest:        { colors: [0x44aa33, 0x88cc44, 0xaacc22, 0xddcc44], vy: -0.018, vxz: 0.006, spread: 9, size: 0.13, spawnY: 4,  endY: -1,   dir: 'down' },
            dungeon:       { colors: [0x776677, 0x998888, 0xaaaaaa],            vy:  0.008, vxz: 0.003, spread: 7, size: 0.07, spawnY: -1, endY:  5,   dir: 'up'   },
            water_swim:    { colors: [0x55aaff, 0x88ccff, 0xaaddff],            vy:  0.012, vxz: 0.002, spread: 6, size: 0.09, spawnY: -2, endY:  5,   dir: 'up'   },
            water_noswim:  { colors: [0x55aaff, 0x88ccff, 0xaaddff],            vy:  0.012, vxz: 0.002, spread: 6, size: 0.09, spawnY: -2, endY:  5,   dir: 'up'   },
            underwater:    { colors: [0x2255cc, 0x4488ff, 0x66aaff],            vy:  0.010, vxz: 0.002, spread: 6, size: 0.10, spawnY: -3, endY:  6,   dir: 'up'   },
            desert:        { colors: [0xddcc88, 0xccbb66, 0xeecc88, 0xffeebb], vy:  0.000, vxz: 0.015, spread: 9, size: 0.07, spawnY:  1, endY: null, dir: 'right' },
            cave:          { colors: [0x6699bb, 0x4477aa, 0x88aacc],            vy: -0.022, vxz: 0.000, spread: 6, size: 0.09, spawnY: 4,  endY: -1,   dir: 'down' },
            swamp:         { colors: [0x556633, 0x667744, 0x887755],            vy:  0.006, vxz: 0.002, spread: 7, size: 0.08, spawnY: -1, endY:  5,   dir: 'up'   },
        };

        function _spawnAmbientParticle(cfg, i, positions, velocities) {
            const cx = cameraTarget.x + (Math.random() - 0.5) * cfg.spread * 2;
            const cz = cameraTarget.z + (Math.random() - 0.5) * cfg.spread * 2;
            // Stagger vertical start
            const cy = cfg.spawnY + (Math.random() - 0.5) * 3;
            positions[i * 3]     = cx;
            positions[i * 3 + 1] = cy;
            positions[i * 3 + 2] = cz;

            const vx = cfg.dir === 'right'
                ? cfg.vxz * (0.5 + Math.random())
                : (Math.random() - 0.5) * cfg.vxz;
            const vz = (Math.random() - 0.5) * cfg.vxz;
            velocities[i] = { x: vx, y: cfg.vy * (0.6 + Math.random() * 0.8), z: vz };
        }

        function initAmbientParticles(sectorType) {
            if (_ambientPoints) { scene.remove(_ambientPoints); _ambientPoints = null; }
            _ambientVelocities = [];
            _ambientSector = sectorType;

            const cfg = _PARTICLE_CFG[sectorType];
            if (!cfg) return; // no effect for city/inside/etc.

            const positions = new Float32Array(AMBIENT_COUNT * 3);
            const colors    = new Float32Array(AMBIENT_COUNT * 3);
            const palette   = cfg.colors.map(c => new THREE.Color(c));

            for (let i = 0; i < AMBIENT_COUNT; i++) {
                _spawnAmbientParticle(cfg, i, positions, _ambientVelocities);
                // Scatter initial Y so they don't all appear at once
                positions[i * 3 + 1] = cfg.spawnY + (Math.random() - 0.5) * Math.abs(cfg.endY != null ? cfg.endY - cfg.spawnY : 6);

                const col = palette[Math.floor(Math.random() * palette.length)];
                colors[i * 3]     = col.r;
                colors[i * 3 + 1] = col.g;
                colors[i * 3 + 2] = col.b;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color',    new THREE.BufferAttribute(colors,    3));

            _ambientPoints = new THREE.Points(geo, new THREE.PointsMaterial({
                size: cfg.size,
                vertexColors: true,
                transparent: true,
                opacity: 0.78,
                sizeAttenuation: true,
                depthWrite: false,
            }));
            scene.add(_ambientPoints);
        }

        function _updateAmbientParticles() {
            if (!_ambientPoints) return;
            const cfg = _PARTICLE_CFG[_ambientSector];
            if (!cfg) return;

            const pos = _ambientPoints.geometry.attributes.position;
            const spread = cfg.spread;

            for (let i = 0; i < AMBIENT_COUNT; i++) {
                const vel = _ambientVelocities[i];
                pos.array[i * 3]     += vel.x;
                pos.array[i * 3 + 1] += vel.y;
                pos.array[i * 3 + 2] += vel.z;

                const py = pos.array[i * 3 + 1];
                const px = pos.array[i * 3];

                // Check if particle needs recycling
                let expired = false;
                if (cfg.dir === 'right') {
                    expired = (px - cameraTarget.x) > spread;
                } else if (cfg.dir === 'down') {
                    expired = py < cfg.endY;
                } else {
                    expired = cfg.endY != null && py > cfg.endY;
                }

                if (expired) {
                    _spawnAmbientParticle(cfg, i, pos.array, _ambientVelocities);
                    // For desert, re-spawn on the left edge
                    if (cfg.dir === 'right') pos.array[i * 3] = cameraTarget.x - spread;
                }
            }
            pos.needsUpdate = true;
        }

        // --- Boss Health Bar ---
        function _updateBossBar(room) {
            const bar = document.getElementById('boss-bar');
            if (!room || !room.mobs || room.mobs.length === 0) {
                bar.style.display = 'none';
                return;
            }
            // Find first boss-type mob that has HP data
            const boss = room.mobs.find(m => classifyMob(m) === 'boss' && m.hp !== undefined && m.maxHp);
            if (boss) {
                document.getElementById('boss-bar-name').textContent = boss.name || 'Boss';
                const pct = Math.max(0, Math.min(100, (boss.hp / boss.maxHp) * 100));
                document.getElementById('boss-bar-fill').style.width = `${pct}%`;
                bar.style.display = 'flex';
            } else {
                bar.style.display = 'none';
            }
        }

        // --- Combat Log ---
        const _MAX_COMBAT_LINES = 100;

        function _formatCombatLine(text) {
            // Append damage number if present
            const dmgMatch = text.match(/\b(\d+)\s*damage\b/i);
            if (dmgMatch && !/\bdmg\b/i.test(text)) {
                return `${text}  [${dmgMatch[1]} dmg]`;
            }
            return text;
        }

        function _addCombatLine(text, type) {
            const formatted = _formatCombatLine(text);
            const el = document.createElement('div');
            el.className = `combat-log-line ${type}`;
            el.textContent = formatted;

            const log = document.getElementById('combat-log-content');
            if (!log) return;
            log.appendChild(el);

            // Auto-scroll
            log.scrollTop = log.scrollHeight;

            // Trim to max lines
            while (log.children.length > _MAX_COMBAT_LINES) {
                log.removeChild(log.firstElementChild);
            }
        }

        function _parseCombatText(text) {
            const lines = text.split('\n');
            lines.forEach(line => {
                const t = line.replace(/\s+/g, ' ').trim();
                if (!t) return;

                // Level up (handled separately, has its own full effect)
                if (/you gain a level|welcome to level/i.test(t)) {
                    _triggerLevelUp();
                    return;
                }

                // Elemental resist / immune / absorb
                if (/resist|resisted|immune|immunity|absorbs? the|no effect on you/i.test(t)) {
                    _addCombatLine(t, 'resist');
                    return;
                }
                // Vulnerable / exposed
                if (/vulnerable|exposed|weak to|takes extra|sears through/i.test(t)) {
                    _addCombatLine(t, 'vuln');
                    return;
                }

                // Player takes damage
                if (/\bhit(?:s)? you\b|\bwound(?:s)? you\b|\bmaul(?:s)? you\b|\bclaw(?:s)? you\b|bites you|kicks you|blasts you|zaps you|strikes you|slashes you|smashes you|crushes you|pierces you|you are hit\b/i.test(t)) {
                    _addCombatLine(t, 'damage');
                    screenFlash('rgba(220,20,20,0.38)', 520);
                    cameraShake(0.35, 400);
                    return;
                }

                // Critical hits / massive blows (player dealing)
                if (/CRITICAL HIT|ANNIHILATE|OBLITERATE|MASSACRE|DEMOLISH|\*\*\*.*CRITICAL|\bDEVASTAT/i.test(t)) {
                    _addCombatLine(t, 'critical');
                    screenFlash('rgba(255,100,0,0.3)', 300);
                    return;
                }

                // Player attacks / deals damage
                if (/^you (hit|wound|maul|claw|bite|kick|blast|zap|strike|slash|smash|crush|pierce|annihilate|obliterate|massacre|demolish|feint|backstab|disembowel|dismember|eviscerate)/i.test(t)) {
                    _addCombatLine(t, 'attack');
                    return;
                }

                // Heals
                if (/you feel better|you recover|you are healed|you feel your wounds|health restored/i.test(t)) {
                    _addCombatLine(t, 'heal');
                    return;
                }

                // Mob kill (player scores a kill) ‚Äî gold "kill" type
                if (/is dead!|has been killed|is slain!/i.test(t) && !/you are dead|you are slain/i.test(t)) {
                    _addCombatLine(t, 'kill');
                    const deadMatch = t.match(/^(?:the\s+)?(.+?)\s+(?:is dead!|has been killed|is slain!)/i);
                    if (deadMatch) markMobDead(deadMatch[1].trim());
                    return;
                }

                // Player death
                if (/you are dead!|you are slain/i.test(t)) {
                    _addCombatLine(t, 'death');
                    screenFlash('rgba(0,0,0,0.85)', 2500);
                    return;
                }
            });
        }

        // --- Level Up Effect ---
        let _levelupParticles = null;
        let _levelupStart = 0;
        const _LEVELUP_DUR = 2800;

        function _triggerLevelUp() {
            screenFlash('rgba(255,215,0,0.55)', 1100);

            // Animated banner
            const banner = document.getElementById('levelup-banner');
            banner.style.display = 'block';
            banner.style.opacity = '1';
            banner.style.transition = 'none';
            banner.style.transform = 'translate(-50%, -50%)';
            void banner.offsetWidth;
            setTimeout(() => {
                banner.style.transition = 'opacity 1.2s ease, transform 1.8s ease';
                banner.style.opacity = '0';
                banner.style.transform = 'translate(-50%, -130%)';
            }, 900);
            setTimeout(() => {
                banner.style.display = 'none';
                banner.style.transform = 'translate(-50%, -50%)';
            }, _LEVELUP_DUR);

            // Gold particle burst
            const origin = playerMarker
                ? playerMarker.position.clone()
                : cameraTarget.clone();
            _spawnLevelUpBurst(origin);
        }

        function _spawnLevelUpBurst(origin) {
            if (_levelupParticles) { scene.remove(_levelupParticles); _levelupParticles = null; }

            const count = 70;
            const positions = new Float32Array(count * 3);
            const colors    = new Float32Array(count * 3);
            const vels = [];
            const palette = [
                new THREE.Color(0xffd700),
                new THREE.Color(0xffaa00),
                new THREE.Color(0xffff88),
                new THREE.Color(0xffffff),
                new THREE.Color(0xff8800),
            ];

            for (let i = 0; i < count; i++) {
                positions[i * 3]     = origin.x;
                positions[i * 3 + 1] = origin.y + 0.5;
                positions[i * 3 + 2] = origin.z;

                const col = palette[Math.floor(Math.random() * palette.length)];
                colors[i * 3]     = col.r;
                colors[i * 3 + 1] = col.g;
                colors[i * 3 + 2] = col.b;

                const theta = Math.random() * Math.PI * 2;
                const phi   = Math.random() * Math.PI;
                const spd   = 0.04 + Math.random() * 0.09;
                vels.push({
                    x: Math.sin(phi) * Math.cos(theta) * spd,
                    y: 0.05 + Math.random() * 0.08,
                    z: Math.sin(phi) * Math.sin(theta) * spd,
                });
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color',    new THREE.BufferAttribute(colors,    3));
            geo.userData.vels = vels;

            _levelupParticles = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.20,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                sizeAttenuation: true,
                depthWrite: false,
            }));
            scene.add(_levelupParticles);
            _levelupStart = Date.now();
        }

        function _updateLevelUpParticles() {
            if (!_levelupParticles) return;
            const t = (Date.now() - _levelupStart) / _LEVELUP_DUR;
            if (t >= 1) { scene.remove(_levelupParticles); _levelupParticles = null; return; }

            const pos  = _levelupParticles.geometry.attributes.position;
            const vels = _levelupParticles.geometry.userData.vels;
            for (let i = 0; i < pos.count; i++) {
                pos.array[i * 3]     += vels[i].x;
                pos.array[i * 3 + 1] += vels[i].y;
                pos.array[i * 3 + 2] += vels[i].z;
                vels[i].y -= 0.0018; // gravity drag
            }
            pos.needsUpdate = true;
            _levelupParticles.material.opacity = 1 - t;
        }

        // ============================================
        // Three.js Setup
        // ============================================
        
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 50, 150);
            
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                cameraDistance * aspect / -2,
                cameraDistance * aspect / 2,
                cameraDistance / 2,
                cameraDistance / -2,
                0.1,
                1000
            );
            
            updateCameraPosition();
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Lighting ‚Äî boosted for MeshStandardMaterial
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.55);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xfff5e0, 1.1);
            dirLight.position.set(20, 40, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Cool fill from opposite side for depth contrast
            const fillLight = new THREE.DirectionalLight(0x8899cc, 0.45);
            fillLight.position.set(-20, 10, -20);
            scene.add(fillLight);

            // Rim light from below for emissive sector pop
            const rimLight = new THREE.DirectionalLight(0x220033, 0.3);
            rimLight.position.set(0, -10, 0);
            scene.add(rimLight);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onCanvasClick);
            renderer.domElement.addEventListener('mousemove', onCanvasHover);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mousemove', onMouseDrag);
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            
            // Touch events
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            
            animate();
        }
        
        function updateCameraPosition() {
            const x = Math.cos(cameraAngle) * Math.cos(cameraPitch) * cameraDistance;
            const y = Math.sin(cameraPitch) * cameraDistance;
            const z = Math.sin(cameraAngle) * Math.cos(cameraPitch) * cameraDistance;
            
            targetCameraPos.set(
                cameraTarget.x + x,
                cameraTarget.y + y,
                cameraTarget.z + z
            );
        }
        
        function updateCameraFrustum() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = cameraDistance * aspect / -2;
            camera.right = cameraDistance * aspect / 2;
            camera.top = cameraDistance / 2;
            camera.bottom = cameraDistance / -2;
            camera.updateProjectionMatrix();
        }
        
        function onWindowResize() {
            updateCameraFrustum();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseWheel(e) {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.05;
            cameraDistance = Math.max(CONFIG.MIN_ZOOM, Math.min(CONFIG.MAX_ZOOM, cameraDistance));
            updateCameraFrustum();
            updateCameraPosition();
        }
        
        function onMouseDown(e) {
            if (e.button === 2) { // Right click
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        }
        
        function onMouseUp(e) {
            isDragging = false;
        }
        
        function onMouseDrag(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            cameraAngle -= deltaX * 0.01;
            cameraPitch = Math.max(0.1, Math.min(Math.PI / 2.5, cameraPitch + deltaY * 0.01));
            
            updateCameraPosition();
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
        
        // Touch handling
        let touchStartX, touchStartY, lastTouchDist;
        
        function onTouchStart(e) {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                lastTouchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        }
        
        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                cameraAngle -= deltaX * 0.005;
                cameraPitch = Math.max(0.1, Math.min(Math.PI / 2.5, cameraPitch + deltaY * 0.005));
                updateCameraPosition();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const delta = lastTouchDist - dist;
                cameraDistance += delta * 0.1;
                cameraDistance = Math.max(CONFIG.MIN_ZOOM, Math.min(CONFIG.MAX_ZOOM, cameraDistance));
                updateCameraFrustum();
                updateCameraPosition();
                lastTouchDist = dist;
            }
        }
        
        function onTouchEnd(e) {}
        
        function zoomIn() {
            cameraDistance = Math.max(CONFIG.MIN_ZOOM, cameraDistance - 10);
            updateCameraFrustum();
            updateCameraPosition();
        }
        
        function zoomOut() {
            cameraDistance = Math.min(CONFIG.MAX_ZOOM, cameraDistance + 10);
            updateCameraFrustum();
            updateCameraPosition();
        }
        
        function resetCamera() {
            cameraAngle = Math.PI / 4;
            cameraPitch = Math.PI / 6;
            cameraDistance = CONFIG.CAMERA_DISTANCE;
            updateCameraFrustum();
            updateCameraPosition();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth camera follow
            camera.position.lerp(targetCameraPos, CONFIG.LERP_SPEED);
            camera.lookAt(cameraTarget);

            // VFX updates
            _applyCameraShake();
            _updateAmbientParticles();
            _updateLevelUpParticles();
            
            // Animate water tiles
            const time = Date.now() * 0.001;
            roomMeshes.forEach((mesh, vnum) => {
                if (mesh.userData.isWater) {
                    mesh.position.y = mesh.userData.baseY + Math.sin(time * 2 + vnum) * 0.05;
                }
            });
            
            // Pulse player glow ring
            if (playerMarker) {
                const ring = playerMarker.children.find(c => c.geometry?.type === 'RingGeometry');
                if (ring) {
                    ring.material.opacity = 0.4 + Math.sin(time * 3) * 0.2;
                    const s = 1 + Math.sin(time * 3) * 0.05;
                    ring.scale.set(s, s, 1);
                }
            }
            
            // Combat flash on hostile mobs in current room
            if (inCombat) {
                roomMeshes.forEach(mesh => {
                    if (!mesh.userData.room) return;
                    mesh.children.forEach(child => {
                        if (child.userData?.mobType && 
                            (child.userData.mobType === 'humanoid' || child.userData.mobType === 'boss' ||
                             child.userData.mobType === 'undead' || child.userData.mobType === 'demon' ||
                             child.userData.mobType === 'dragon')) {
                            const sprite = child.children[0];
                            if (sprite?.material) {
                                sprite.material.color.setHSL(0, 1, 0.5 + Math.sin(time * 8) * 0.3);
                            }
                        }
                    });
                });
            }
            
            // Pulse exit arrows on current room
            connectorMeshes.forEach(obj => {
                // Direct sprites (up/down badges) or group children
                const sprites = obj.isSprite ? [obj] : (obj.children || []);
                sprites.forEach(s => {
                    if (s.userData?.pulseExit) {
                        s.material.opacity = 0.72 + Math.sin(time * 3.5) * 0.28;
                        const ps = 1 + Math.sin(time * 3.5) * 0.06;
                        s.scale.set(
                            s.userData._baseScale ? s.userData._baseScale * ps : ps,
                            s.userData._baseScale ? s.userData._baseScale * ps : ps,
                            1
                        );
                    }
                });
            });

            // Tick sprite animators
            tickAnimators();
            updateFloatingTexts();
            updateHitParticles();

            renderer.render(scene, camera);
        }
        
        // ============================================
        // Room Rendering
        // ============================================
        
        function worldToIso(x, y, z) {
            const spacing = CONFIG.TILE_SIZE + CONFIG.TILE_GAP;
            return new THREE.Vector3(
                x * spacing,
                z * (CONFIG.TILE_SIZE * 0.8),
                y * spacing
            );
        }
        
        function createRoomMesh(room, isCurrentRoom = false) {
            const cfg = SECTOR_COLORS[room.sector] || SECTOR_COLORS['default'];
            const isWater = room.sector?.includes('water') || room.sector === 'underwater';

            const geometry = new THREE.BoxGeometry(
                CONFIG.TILE_SIZE,
                CONFIG.TILE_HEIGHT,
                CONFIG.TILE_SIZE
            );

            const topMaterial = new THREE.MeshStandardMaterial({
                color: cfg.top,
                emissive: isCurrentRoom ? 0x443300 : (cfg.emissive || 0x000000),
                roughness: cfg.roughness ?? 0.85,
                metalness: cfg.metalness ?? 0.05,
            });

            const sideMaterial = new THREE.MeshStandardMaterial({
                color: cfg.side,
                emissive: cfg.emissive ? new THREE.Color(cfg.emissive).multiplyScalar(0.5) : 0x000000,
                roughness: (cfg.roughness ?? 0.85) + 0.05,
                metalness: cfg.metalness ?? 0.05,
            });

            const materials = [
                sideMaterial, sideMaterial,
                topMaterial,  sideMaterial,
                sideMaterial, sideMaterial,
            ];

            const mesh = new THREE.Mesh(geometry, materials);
            const pos = worldToIso(room.x, room.y, room.z);
            mesh.position.copy(pos);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            mesh.userData = {
                vnum: room.vnum,
                room: room,
                isWater: isWater,
                baseY: pos.y
            };

            // Edge outline ‚Äî gold for current room, sector-tinted for others
            const edges = new THREE.EdgesGeometry(geometry);
            const edgeColor = isCurrentRoom ? 0xffd700 : (cfg.edge || 0x888899);
            const edgeOpacity = isCurrentRoom ? 1.0 : 0.35;
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: edgeColor, transparent: true, opacity: edgeOpacity })
            );
            mesh.add(line);

            return mesh;
        }
        
        function createConnector(fromPos, toPos, isVertical = false) {
            // Bright glowing line between tile centers
            const color = isVertical ? 0x44ddff : 0x55eeff;
            const material = new THREE.LineBasicMaterial({
                color,
                transparent: true,
                opacity: isVertical ? 0.9 : 0.75,
            });
            const y = CONFIG.TILE_HEIGHT + 0.04;
            const points = [
                fromPos.clone().add(new THREE.Vector3(0, y, 0)),
                toPos.clone().add(new THREE.Vector3(0, y, 0))
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            return new THREE.Line(geometry, material);
        }

        // Create exit arrow/indicator on a tile edge
        function createExitArrow(tilePos, dir, explored, isCurrentRoom) {
            const S = CONFIG.TILE_SIZE;
            const H = CONFIG.TILE_HEIGHT;
            const half = S * 0.5 - 0.08;
            const y = H + 0.07;

            const edgeMap = {
                north: { ex: 0,     ez: -half, angle: 0,           label: 'N' },
                south: { ex: 0,     ez:  half, angle: Math.PI,     label: 'S' },
                east:  { ex: half,  ez:  0,    angle: Math.PI/2,   label: 'E' },
                west:  { ex: -half, ez:  0,    angle: -Math.PI/2,  label: 'W' },
            };

            const edge = edgeMap[dir];

            // ‚îÄ‚îÄ Up / Down vertical exits ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if (!edge && (dir === 'up' || dir === 'down')) {
                const isUp = dir === 'up';
                const sz = isCurrentRoom ? 72 : 52;
                const canvas = document.createElement('canvas');
                canvas.width = sz; canvas.height = sz;
                const ctx = canvas.getContext('2d');
                const r = sz / 2;

                ctx.beginPath();
                ctx.arc(r, r, r - 2, 0, Math.PI * 2);
                ctx.fillStyle = isUp ? 'rgba(50,200,120,0.93)' : 'rgba(200,120,30,0.93)';
                ctx.fill();
                ctx.strokeStyle = isUp ? '#88ffcc' : '#ffcc66';
                ctx.lineWidth = isCurrentRoom ? 3 : 2;
                ctx.stroke();

                ctx.fillStyle = isCurrentRoom ? '#fff' : '#000';
                ctx.font = `bold ${isCurrentRoom ? Math.round(sz*0.42) : Math.round(sz*0.38)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(isUp ? '‚ñ≤' : '‚ñº', r, r + 1);

                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, renderOrder: 999 });
                const sprite = new THREE.Sprite(mat);
                const scale = isCurrentRoom ? 0.65 : 0.42;
                sprite.scale.set(scale, scale, 1);
                sprite.userData._baseScale = scale;
                sprite.position.set(tilePos.x, tilePos.y + H + (isUp ? 0.90 : 0.45), tilePos.z);

                // Pulse tag for current room
                if (isCurrentRoom) sprite.userData.pulseExit = true;

                scene.add(sprite);
                connectorMeshes.push(sprite);
                return null;
            }

            // ‚îÄ‚îÄ Non-cardinal exits (portal/arch/etc.) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if (!edge) {
                const sz = isCurrentRoom ? 88 : 70;
                const canvas = document.createElement('canvas');
                canvas.width = sz; canvas.height = 36;
                const ctx = canvas.getContext('2d');
                const label = String(dir).slice(0, 8);

                ctx.fillStyle = isCurrentRoom ? 'rgba(180,90,255,0.9)' : 'rgba(120,120,180,0.8)';
                ctx.strokeStyle = isCurrentRoom ? '#f0d0ff' : '#aaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const r = 8;
                ctx.moveTo(r, 0); ctx.lineTo(sz - r, 0); ctx.quadraticCurveTo(sz, 0, sz, r);
                ctx.lineTo(sz, 36 - r); ctx.quadraticCurveTo(sz, 36, sz - r, 36);
                ctx.lineTo(r, 36); ctx.quadraticCurveTo(0, 36, 0, 36 - r);
                ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, sz / 2, 18);

                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, renderOrder: 999 });
                const sprite = new THREE.Sprite(mat);
                const scale = isCurrentRoom ? 0.7 : 0.55;
                sprite.scale.set(scale, scale * 0.45, 1);
                sprite.userData._baseScale = scale;
                sprite.position.set(tilePos.x, tilePos.y + H + 0.55, tilePos.z);
                if (isCurrentRoom) sprite.userData.pulseExit = true;
                scene.add(sprite);
                connectorMeshes.push(sprite);
                return null;
            }

            // ‚îÄ‚îÄ Cardinal exits ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const canvSize = isCurrentRoom ? 64 : 40;
            const canvas = document.createElement('canvas');
            canvas.width = canvSize; canvas.height = canvSize;
            const ctx = canvas.getContext('2d');
            const c = canvSize / 2;

            if (isCurrentRoom) {
                // Bright gold pill with direction label
                ctx.save();
                ctx.translate(c, c);
                ctx.rotate(edge.angle);

                // Arrowhead body
                ctx.beginPath();
                ctx.moveTo(0, -c + 4);
                ctx.lineTo(c - 6, c - 10);
                ctx.lineTo(0, c - 18);
                ctx.lineTo(-(c - 6), c - 10);
                ctx.closePath();
                ctx.fillStyle = 'rgba(255,215,60,0.95)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,180,0.85)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();

                // Direction label centred on sprite
                ctx.fillStyle = '#000';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(edge.label, c, c);

            } else if (explored) {
                // Smaller cyan chevron
                ctx.save();
                ctx.translate(c, c);
                ctx.rotate(edge.angle);
                ctx.beginPath();
                ctx.moveTo(0, -c + 6);
                ctx.lineTo(c - 8, c - 10);
                ctx.lineTo(0, c - 16);
                ctx.lineTo(-(c - 8), c - 10);
                ctx.closePath();
                ctx.fillStyle = 'rgba(80,200,240,0.75)';
                ctx.fill();
                ctx.restore();

            } else {
                // Dim grey chevron for unexplored frontier
                ctx.save();
                ctx.translate(c, c);
                ctx.rotate(edge.angle);
                ctx.beginPath();
                ctx.moveTo(0, -c + 8);
                ctx.lineTo(c - 10, c - 12);
                ctx.lineTo(0, c - 18);
                ctx.lineTo(-(c - 10), c - 12);
                ctx.closePath();
                ctx.fillStyle = 'rgba(130,130,170,0.5)';
                ctx.fill();
                ctx.restore();
            }

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, renderOrder: 10 });
            const sprite = new THREE.Sprite(mat);
            const scale = isCurrentRoom ? 0.70 : (explored ? 0.36 : 0.30);
            sprite.scale.set(scale, scale, 1);
            sprite.userData._baseScale = scale;
            sprite.position.set(tilePos.x + edge.ex, tilePos.y + y, tilePos.z + edge.ez);

            if (isCurrentRoom) sprite.userData.pulseExit = true;

            const group = new THREE.Group();
            group.add(sprite);
            return group;
        }
        
        // ============================================
        // ============================================
        // Sprite Animation System
        // ============================================

        const ANIM_FPS = 10;
        const ANIM_STATES = {
            idle:   { frames: 4, loop: true,  next: 'idle' },
            walk:   { frames: 4, loop: true,  next: 'idle' },
            attack: { frames: 6, loop: false, next: 'idle' },
            hurt:   { frames: 3, loop: false, next: 'idle' },
            death:  { frames: 8, loop: false, next: null   },
        };

        class SpriteAnimator {
            constructor(def, isPlayer = false) {
                this.def = def;
                this.isPlayer = isPlayer;
                this.state = 'idle';
                this.frame = 0;
                this.elapsed = 0;
                this.done = false;
                this._texCache = new Map();
            }

            setState(state) {
                if (this.state === 'death') return; // death is terminal
                if (this.state === state) return;
                this.state = state;
                this.frame = 0;
                this.elapsed = 0;
                this.done = false;
            }

            update(delta) {
                this.elapsed += delta;
                const frameDur = 1 / ANIM_FPS;
                const cfg = ANIM_STATES[this.state] || ANIM_STATES.idle;
                if (this.elapsed >= frameDur) {
                    this.elapsed -= frameDur;
                    this.frame++;
                    if (this.frame >= cfg.frames) {
                        if (cfg.loop) {
                            this.frame = 0;
                        } else {
                            this.frame = cfg.frames - 1;
                            this.done = true;
                            if (cfg.next) this.setState(cfg.next);
                        }
                    }
                }
            }

            getTexture() {
                const key = `${this.state}-${this.frame}`;
                if (this._texCache.has(key)) return this._texCache.get(key);
                const tex = new THREE.CanvasTexture(this._drawFrame(this.state, this.frame));
                this._texCache.set(key, tex);
                return tex;
            }

            _drawFrame(state, frame) {
                const size = 64;
                const canvas = document.createElement('canvas');
                canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d');
                const def = this.def;
                const cx = size / 2, cy = size / 2;
                const t = frame / Math.max(1, (ANIM_STATES[state]?.frames || 1) - 1); // 0‚Üí1

                // Base circle
                const r = size / 2 - 4;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fillStyle = def.bg;
                ctx.fill();

                // Animate per state
                let scale = 1, offsetY = 0, alpha = 1, flashColor = null;

                if (state === 'idle') {
                    // Gentle pulse
                    scale = 1 + Math.sin(t * Math.PI * 2) * 0.05;
                    if (this.isPlayer) {
                        // Extra glow ring for player
                        ctx.beginPath();
                        ctx.arc(cx, cy, r + 3 + Math.sin(t * Math.PI * 2) * 2, 0, Math.PI * 2);
                        ctx.strokeStyle = def.border + '66';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                } else if (state === 'walk') {
                    offsetY = Math.sin(t * Math.PI * 4) * 3;
                } else if (state === 'attack') {
                    if (t < 0.4) {
                        scale = 1 + t * 0.5; // grow
                        offsetY = -t * 8;    // lunge up
                    } else {
                        scale = 1.2 - (t - 0.4) * 0.4; // shrink back
                        offsetY = -(1 - t) * 8;
                    }
                    // Slash arc in attack peak
                    if (t > 0.2 && t < 0.6) {
                        ctx.beginPath();
                        ctx.arc(cx + 10, cy, 14, -Math.PI * 0.8, Math.PI * 0.2);
                        ctx.strokeStyle = def.border + 'aa';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                } else if (state === 'hurt') {
                    flashColor = 'rgba(255,255,255,0.7)';
                    scale = 1 - t * 0.15;
                } else if (state === 'death') {
                    scale = 1 - t * 0.9;
                    alpha = 1 - t;
                }

                // Apply scale/offset/alpha
                ctx.save();
                ctx.translate(cx, cy + offsetY);
                ctx.scale(scale, scale);
                ctx.translate(-cx, -cy);
                ctx.globalAlpha = alpha;

                // Redraw circle with transform
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fillStyle = def.bg;
                ctx.fill();

                // Border
                ctx.strokeStyle = def.border;
                ctx.lineWidth = this.isPlayer ? 4 : 2.5;
                ctx.stroke();

                // Symbol
                this._drawSymbol(ctx, cx, cy, size, def);

                // Flash overlay
                if (flashColor) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    ctx.fillStyle = flashColor;
                    ctx.fill();
                }

                ctx.restore();
                return canvas;
            }

            _drawSymbol(ctx, cx, cy, size, def) {
                const sc = size * 0.22;
                ctx.fillStyle = def.border;
                ctx.strokeStyle = def.border;
                ctx.lineWidth = 2;
                const sym = def.symbol || 'dot';

                if (sym === 'cross') {
                    ctx.fillRect(cx - 2, cy - sc, 4, sc * 2);
                    ctx.fillRect(cx - sc * 0.6, cy - 2, sc * 1.2, 4);
                } else if (sym === 'skull') {
                    ctx.beginPath();
                    ctx.arc(cx, cy - 3, sc * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(cx - sc * 0.5, cy + 3, sc, sc * 0.6);
                } else if (sym === 'diamond') {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - sc); ctx.lineTo(cx + sc * 0.7, cy);
                    ctx.lineTo(cx, cy + sc); ctx.lineTo(cx - sc * 0.7, cy);
                    ctx.closePath(); ctx.fill();
                } else if (sym === 'star') {
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const a = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const b = (i * 4 * Math.PI / 5 + 2 * Math.PI / 5) - Math.PI / 2;
                        ctx.lineTo(cx + Math.cos(a) * sc, cy + Math.sin(a) * sc);
                        ctx.lineTo(cx + Math.cos(b) * sc * 0.4, cy + Math.sin(b) * sc * 0.4);
                    }
                    ctx.closePath(); ctx.fill();
                } else if (sym === 'wave') {
                    ctx.beginPath();
                    ctx.moveTo(cx - sc, cy);
                    for (let x = -sc; x <= sc; x += 2) ctx.lineTo(cx + x, cy + Math.sin(x * 0.3) * sc * 0.5);
                    ctx.lineWidth = 3; ctx.stroke();
                } else if (sym === 'shield') {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - sc); ctx.lineTo(cx + sc * 0.8, cy - sc * 0.3);
                    ctx.lineTo(cx + sc * 0.8, cy + sc * 0.3); ctx.lineTo(cx, cy + sc);
                    ctx.lineTo(cx - sc * 0.8, cy + sc * 0.3); ctx.lineTo(cx - sc * 0.8, cy - sc * 0.3);
                    ctx.closePath(); ctx.fill();
                } else if (sym === 'cart') {
                    ctx.fillRect(cx - sc * 0.7, cy - sc * 0.4, sc * 1.4, sc * 0.8);
                    ctx.beginPath();
                    ctx.arc(cx - sc * 0.4, cy + sc * 0.5, sc * 0.25, 0, Math.PI * 2);
                    ctx.arc(cx + sc * 0.4, cy + sc * 0.5, sc * 0.25, 0, Math.PI * 2);
                    ctx.fillStyle = def.bg; ctx.fill();
                    ctx.strokeStyle = def.border; ctx.lineWidth = 1.5; ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(cx, cy, sc * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Track all active animators: { sprite: THREE.Sprite, animator: SpriteAnimator }
        const activeAnimators = [];
        let lastAnimTime = performance.now();

        function tickAnimators() {
            const now = performance.now();
            const delta = (now - lastAnimTime) / 1000;
            lastAnimTime = now;
            for (const { sprite, animator } of activeAnimators) {
                animator.update(delta);
                const tex = animator.getTexture();
                if (sprite.material.map !== tex) {
                    sprite.material.map = tex;
                    sprite.material.needsUpdate = true;
                }
            }
        }

        // Floating damage numbers
        const floatingTexts = [];

        function spawnFloatingText(worldPos, text, color = '#ff4444') {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 48;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 28px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(text, 64, 34);
            ctx.fillText(text, 64, 34);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(2, 0.75, 1);
            sprite.position.copy(worldPos);
            sprite.position.y += 1.5;
            scene.add(sprite);
            floatingTexts.push({ sprite, born: Date.now(), duration: 1500, startY: sprite.position.y });
        }

        function updateFloatingTexts() {
            const now = Date.now();
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                const t = (now - ft.born) / ft.duration;
                if (t >= 1) { scene.remove(ft.sprite); floatingTexts.splice(i, 1); continue; }
                ft.sprite.position.y = ft.startY + t * 2;
                ft.sprite.material.opacity = 1 - t;
            }
        }

        // Hit particles
        const hitParticleSystems = [];

        function spawnHitParticles(worldPos, type = 'slash') {
            const colorMap = {
                slash: [0xff4444, 0xff8800],
                magic: [0xaa44ff, 0xff44ff],
                fire:  [0xff6600, 0xffaa00],
                ice:   [0x44ddff, 0xaaeeff],
                holy:  [0xffd700, 0xffffff],
            };
            const colors = colorMap[type] || colorMap.slash;
            const count = 8;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = [];
            for (let i = 0; i < count; i++) {
                positions[i * 3] = worldPos.x;
                positions[i * 3 + 1] = worldPos.y + 1;
                positions[i * 3 + 2] = worldPos.z;
                velocities.push({
                    x: (Math.random() - 0.5) * 4,
                    y: Math.random() * 3 + 1,
                    z: (Math.random() - 0.5) * 4
                });
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                size: 0.3, transparent: true, depthTest: false
            });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            hitParticleSystems.push({ points, velocities, born: Date.now(), duration: 600 });
        }

        function updateHitParticles() {
            const now = Date.now();
            for (let i = hitParticleSystems.length - 1; i >= 0; i--) {
                const ps = hitParticleSystems[i];
                const t = (now - ps.born) / ps.duration;
                if (t >= 1) { scene.remove(ps.points); hitParticleSystems.splice(i, 1); continue; }
                const pos = ps.points.geometry.attributes.position;
                for (let j = 0; j < ps.velocities.length; j++) {
                    const v = ps.velocities[j];
                    pos.array[j * 3]     += v.x * 0.016;
                    pos.array[j * 3 + 1] += (v.y - 5 * t) * 0.016; // gravity
                    pos.array[j * 3 + 2] += v.z * 0.016;
                }
                pos.needsUpdate = true;
                ps.points.material.opacity = 1 - t;
            }
        }

        // Billboard Sprite System
        // ============================================
        
        // Sprite cache: key -> THREE.Texture
        const spriteCache = new Map();

        // Mob type classifier
        function classifyMob(mob) {
            const name = (mob.name || '').toLowerCase();
            const flags = mob.flags || [];

            // Boss check first (always overrides)
            if (mob.boss || flags.includes('boss') ||
                name.includes('king') || name.includes('queen') || name.includes('lord') ||
                name.includes('arch') || name.includes('ancient lich') || name.includes('demon lord')) {
                return 'boss';
            }

            // Shopkeeper check
            if (mob.shopkeeper || name.includes('shopkeeper') || name.includes('merchant') ||
                name.includes('vendor') || name.includes('baker') || name.includes('blacksmith') ||
                name.includes('innkeeper') || name.includes('trainer') || name.includes('guild')) {
                return 'shopkeeper';
            }

            // Name-based classification FIRST (before hostile check)
            if (name.includes('dragon') || name.includes('wyvern') || name.includes('wyrm')) return 'dragon';
            if (name.includes('demon') || name.includes('devil') || name.includes('fiend') || name.includes('imp') || name.includes('balrog')) return 'demon';
            if (name.includes('skeleton') || name.includes('zombie') || name.includes('ghoul') ||
                name.includes('ghost') || name.includes('wraith') || name.includes('lich') ||
                name.includes('undead') || name.includes('vampire') || name.includes('mummy') ||
                name.includes('shade') || name.includes('spectre') || name.includes('wight')) return 'undead';
            if (name.includes('elemental') || name.includes('golem') || name.includes('construct') ||
                name.includes('gargoyle') || name.includes('automaton')) return 'elemental';
            if (name.includes('giant') || name.includes('titan') || name.includes('cyclops') || name.includes('troll')) return 'humanoid';
            if (name.includes('wolf') || name.includes('bear') || name.includes('lion') ||
                name.includes('tiger') || name.includes('spider') || name.includes('snake') ||
                name.includes('boar') || name.includes('rat') || name.includes('bat') ||
                name.includes('cat') || name.includes('dog') || name.includes('horse') ||
                name.includes('bird') || name.includes('hawk') || name.includes('eagle') ||
                name.includes('were') || name.includes('basilisk') || name.includes('hydra') ||
                name.includes('manticore') || name.includes('worm') || name.includes('slug')) return 'beast';
            if (name.includes('orc') || name.includes('goblin') || name.includes('gnoll') ||
                name.includes('hobgoblin') || name.includes('kobold') || name.includes('ogre') ||
                name.includes('bugbear') || name.includes('bandit') || name.includes('brigand') ||
                name.includes('guard') || name.includes('soldier') || name.includes('warrior')) return 'humanoid';

            // Now check hostile for final fallback
            if (!mob.hostile) return 'friendly';
            return 'humanoid';
        }

        // Sprite definitions: symbol + bg color + border color + size
        const SPRITE_DEFS = {
            player:     { symbol: 'star',    bg: '#1a1a00', border: '#ffd700', size: 1.2 },
            boss:       { symbol: 'diamond', bg: '#1a001a', border: '#cc00ff', size: 1.8 },
            dragon:     { symbol: 'diamond', bg: '#1a0000', border: '#ff4400', size: 1.6 },
            demon:      { symbol: 'diamond', bg: '#110011', border: '#990099', size: 1.4 },
            undead:     { symbol: 'skull',   bg: '#0a0a0a', border: '#44ffaa', size: 1.2 },
            beast:      { symbol: 'dot',     bg: '#0a0800', border: '#aaaa00', size: 1.1 },
            elemental:  { symbol: 'wave',    bg: '#000a1a', border: '#00aaff', size: 1.2 },
            humanoid:   { symbol: 'cross',   bg: '#100000', border: '#ff4444', size: 1.0 },
            friendly:   { symbol: 'dot',     bg: '#001a00', border: '#44ff44', size: 1.0 },
            shopkeeper: { symbol: 'cart',    bg: '#00001a', border: '#4488ff', size: 1.0 },
        };

        // Class-based player symbol overrides
        const CLASS_SPRITES = {
            warrior:    { symbol: 'cross' },
            mage:       { symbol: 'wave' },
            cleric:     { symbol: 'shield' },
            thief:      { symbol: 'cross' },
            assassin:   { symbol: 'cross' },
            ranger:     { symbol: 'dot' },
            bard:       { symbol: 'wave' },
            necromancer:{ symbol: 'skull' },
            paladin:    { symbol: 'shield' },
        };

        function makeSpriteTexture(def, isPlayer = false) {
            const cacheKey = `${def.border}-${def.bg}-${isPlayer}`;
            if (spriteCache.has(cacheKey)) return spriteCache.get(cacheKey);

            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const cx = size / 2, cy = size / 2, r = size / 2 - 3;

            // Outer glow for player/boss
            if (isPlayer || def.size >= 1.6) {
                ctx.beginPath();
                ctx.arc(cx, cy, r + 2, 0, Math.PI * 2);
                ctx.fillStyle = def.border + '55';
                ctx.fill();
            }

            // Background fill
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fillStyle = def.bg;
            ctx.fill();

            // Border
            ctx.strokeStyle = def.border;
            ctx.lineWidth = isPlayer ? 4 : 2.5;
            ctx.stroke();

            // Inner symbol ‚Äî drawn with primitives, no emoji
            ctx.fillStyle = def.border;
            ctx.strokeStyle = def.border;
            ctx.lineWidth = 2;

            const sym = def.symbol || 'dot';
            const sc = size * 0.22; // symbol scale

            if (sym === 'cross') {
                // Sword cross shape
                ctx.fillRect(cx - 2, cy - sc, 4, sc * 2);
                ctx.fillRect(cx - sc * 0.6, cy - 2, sc * 1.2, 4);
            } else if (sym === 'skull') {
                ctx.beginPath();
                ctx.arc(cx, cy - 3, sc * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(cx - sc * 0.5, cy + 3, sc, sc * 0.6);
            } else if (sym === 'diamond') {
                ctx.beginPath();
                ctx.moveTo(cx, cy - sc);
                ctx.lineTo(cx + sc * 0.7, cy);
                ctx.lineTo(cx, cy + sc);
                ctx.lineTo(cx - sc * 0.7, cy);
                ctx.closePath();
                ctx.fill();
            } else if (sym === 'star') {
                // 5-point star
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a = (i * 4 * Math.PI / 5) - Math.PI / 2;
                    const b = (i * 4 * Math.PI / 5 + 2 * Math.PI / 5) - Math.PI / 2;
                    ctx.lineTo(cx + Math.cos(a) * sc, cy + Math.sin(a) * sc);
                    ctx.lineTo(cx + Math.cos(b) * sc * 0.4, cy + Math.sin(b) * sc * 0.4);
                }
                ctx.closePath();
                ctx.fill();
            } else if (sym === 'wave') {
                ctx.beginPath();
                ctx.moveTo(cx - sc, cy);
                for (let x = -sc; x <= sc; x += 2) {
                    ctx.lineTo(cx + x, cy + Math.sin(x * 0.3) * sc * 0.5);
                }
                ctx.lineWidth = 3;
                ctx.stroke();
            } else if (sym === 'shield') {
                ctx.beginPath();
                ctx.moveTo(cx, cy - sc);
                ctx.lineTo(cx + sc * 0.8, cy - sc * 0.3);
                ctx.lineTo(cx + sc * 0.8, cy + sc * 0.3);
                ctx.lineTo(cx, cy + sc);
                ctx.lineTo(cx - sc * 0.8, cy + sc * 0.3);
                ctx.lineTo(cx - sc * 0.8, cy - sc * 0.3);
                ctx.closePath();
                ctx.fill();
            } else if (sym === 'cart') {
                ctx.fillRect(cx - sc * 0.7, cy - sc * 0.4, sc * 1.4, sc * 0.8);
                ctx.beginPath();
                ctx.arc(cx - sc * 0.4, cy + sc * 0.5, sc * 0.25, 0, Math.PI * 2);
                ctx.arc(cx + sc * 0.4, cy + sc * 0.5, sc * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = def.bg;
                ctx.fill();
                ctx.strokeStyle = def.border;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            } else {
                // dot fallback
                ctx.beginPath();
                ctx.arc(cx, cy, sc * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            spriteCache.set(cacheKey, texture);
            return texture;
        }

        function createBillboardSprite(def, scale = 1.0, isPlayer = false) {
            const animator = new SpriteAnimator(def, isPlayer);
            const material = new THREE.SpriteMaterial({
                map: animator.getTexture(),
                transparent: true,
            });
            const sprite = new THREE.Sprite(material);
            const s = scale * def.size;
            sprite.scale.set(s, s, 1);
            activeAnimators.push({ sprite, animator });
            sprite.userData.animator = animator;
            return sprite;
        }

        function createPlayerMarker(playerClass = '') {
            const group = new THREE.Group();
            
            const cls = (playerClass || '').toLowerCase();
            const classDef = CLASS_SPRITES[cls];
            const def = { ...SPRITE_DEFS.player };
            if (classDef) def.symbol = classDef.symbol;
            
            const sprite = createBillboardSprite(def, 1.0, true);
            sprite.position.y = 0.8;
            group.add(sprite);

            // Glow ring on ground
            const ringGeo = new THREE.RingGeometry(0.4, 0.55, 24);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.02;
            group.add(ring);

            group.userData.isPlayer = true;
            group.userData.sprite = sprite;
            return group;
        }

        // Real sprite image cache
        const realSpriteCache = new Map();

        function loadRealSprite(url, onLoad) {
            if (realSpriteCache.has(url)) { onLoad(realSpriteCache.get(url)); return; }
            const loader = new THREE.TextureLoader();
            loader.load(url, tex => {
                realSpriteCache.set(url, tex);
                onLoad(tex);
            }, undefined, () => { /* 404 = no sprite, use canvas fallback */ });
        }

        function tryApplyRealSprite(sprite, mobType, playerClass = '') {
            const urlMap = {
                // Player classes
                warrior: '/sprites/warrior.png',
                mage: '/sprites/mage.png',
                cleric: '/sprites/cleric.png',
                thief: '/sprites/thief.png',
                assassin: '/sprites/thief.png',
                ranger: '/sprites/ranger.png',
                paladin: '/sprites/paladin.png',
                necromancer: '/sprites/necromancer.png',
                bard: '/sprites/bard.png',
                // Mob types
                humanoid: '/sprites/mob_humanoid.png',
                undead: '/sprites/mob_skeleton.png',
                beast: '/sprites/mob_beast.png',
                dragon: '/sprites/mob_dragon.png',
                demon: '/sprites/mob_demon.png',
                boss: '/sprites/mob_mindflayer.png',
                elemental: '/sprites/elemental.png',
                friendly: '/sprites/friendly.png',
                shopkeeper: '/sprites/shopkeeper.png',
            };
            const key = playerClass || mobType;
            const url = urlMap[key];
            if (!url) return;
            loadRealSprite(url, tex => {
                sprite.material.map = tex;
                sprite.material.needsUpdate = true;
                // Remove from animator since we have real art
                const idx = activeAnimators.findIndex(a => a.sprite === sprite);
                if (idx !== -1) activeAnimators.splice(idx, 1);
            });
        }

        function makeNameLabel(name, color = '#ffffff') {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 40;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(name, 128, 28);
            ctx.fillStyle = color;
            ctx.fillText(name, 128, 28);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
            const label = new THREE.Sprite(mat);
            label.scale.set(2.5, 0.4, 1);
            return label;
        }

        function createMobMarker(mob, index, total, hasOverflow) {
            const group = new THREE.Group();
            
            const mobType = classifyMob(mob);
            const isBoss = mobType === 'boss';

            const dotColors = {
                boss:       0xcc00ff,
                dragon:     0xff4400,
                demon:      0x9900cc,
                undead:     0x44ffaa,
                beast:      0xaaaa00,
                elemental:  0x00aaff,
                humanoid:   0xff4444,
                friendly:   0x44ff44,
                shopkeeper: 0x4488ff,
            };
            const dotColor = dotColors[mobType] || 0xff4444;

            // Dynamic sizing: shrink dots when many mobs share a tile
            let dotR;
            if (isBoss) {
                dotR = 0.22;
            } else if (total <= 2) {
                dotR = 0.14;
            } else if (total <= 4) {
                dotR = 0.12;
            } else if (total <= 6) {
                dotR = 0.10;
            } else {
                dotR = 0.08;
            }

            const dotGeo = new THREE.SphereGeometry(dotR, 8, 8);
            const dotMat = new THREE.MeshBasicMaterial({ color: dotColor });
            const dot = new THREE.Mesh(dotGeo, dotMat);
            dot.position.y = CONFIG.TILE_HEIGHT + dotR + 0.02;
            group.add(dot);

            // Boss pulsing ring
            if (isBoss) {
                const ringGeo = new THREE.RingGeometry(0.5, 0.65, 24);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xcc00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.03;
                ring.userData.isBossGlow = true;
                group.add(ring);
            }

            group.userData = { mob: mob, mobType: mobType };

            // Position dots in a circle; tighten radius when crowded
            const maxVisible = hasOverflow ? 5 : total;
            const radius = isBoss ? 0 : (total <= 1 ? 0 : Math.min(0.42, 0.18 + maxVisible * 0.05));
            const angle = (index / Math.max(maxVisible, 1)) * Math.PI * 2;
            group.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );

            return group;
        }

        function makeMobCountBadge(count) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(20,0,0,0.85)';
            ctx.fill();
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#ff8888';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('+' + count, 32, 33);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
            const badge = new THREE.Sprite(mat);
            badge.scale.set(0.55, 0.55, 1);
            badge.position.set(0, CONFIG.TILE_HEIGHT + 0.55, 0);
            return badge;
        }
        
        // ============================================
        // Map View Mode
        // ============================================
        let mapViewMode = 'zone'; // 'zone' | 'full'
        let lastMapData = null;
        let currentPlayerZone = null;

        function setMapViewMode(mode) {
            mapViewMode = mode;
            document.querySelectorAll('.map-view-btn').forEach(b => {
                b.classList.toggle('active', b.dataset.mode === mode);
            });
            if (lastMapData) renderMap(lastMapData);
        }

        function renderMap(data) {
            lastMapData = data;

            // Track which zone player is in
            if (data.player?.vnum && data.rooms) {
                const pr = data.rooms.find(r => r.vnum === data.player.vnum);
                if (pr) currentPlayerZone = pr.zone;
            }

            // Filter rooms by view mode
            let visibleRooms = data.rooms;
            if (mapViewMode === 'zone' && currentPlayerZone != null) {
                visibleRooms = data.rooms.filter(r => r.zone === currentPlayerZone);
            }

            // Clear existing
            roomMeshes.forEach(mesh => scene.remove(mesh));
            roomMeshes.clear();
            connectorMeshes.forEach(mesh => scene.remove(mesh));
            connectorMeshes = [];
            clearPath();
            roomData.clear();
            // Clear animators (except player)
            activeAnimators.length = 0;
            
            if (!visibleRooms || visibleRooms.length === 0) return;
            
            allRoomsData = visibleRooms;
            const playerVnum = data.player?.vnum;
            
            // Create room meshes
            const roomPositions = new Map();
            visibleRooms.forEach(room => {
                roomData.set(room.vnum, room);
                const isCurrentRoom = room.vnum === playerVnum;
                const mesh = createRoomMesh(room, isCurrentRoom);
                scene.add(mesh);
                roomMeshes.set(room.vnum, mesh);
                roomPositions.set(room.vnum, mesh.position.clone());
                
                // Add mob markers ‚Äî max 5 visible dots + count badge if more
                if (room.mobs && room.mobs.length > 0) {
                    const total = room.mobs.length;
                    const maxVisible = 5;
                    const showCount = total > maxVisible;
                    const visibleCount = showCount ? maxVisible : total;
                    for (let i = 0; i < visibleCount; i++) {
                        const mobMarker = createMobMarker(room.mobs[i], i, total, showCount);
                        mesh.add(mobMarker);
                    }
                    // Count badge for overflow
                    if (showCount) {
                        const badge = makeMobCountBadge(total);
                        mesh.add(badge);
                    }
                }
            });
            
            // Create connectors + exit arrows
            const drawnConnectors = new Set(); // avoid drawing A‚ÜîB twice
            visibleRooms.forEach(room => {
                const fromPos = roomPositions.get(room.vnum);
                if (!fromPos) return;
                const isCurrentRoom = room.vnum === playerVnum;

                const dirOffsets = {
                    'north': { x: 0, y: -1, z: 0 },
                    'south': { x: 0, y: 1, z: 0 },
                    'east':  { x: 1, y: 0, z: 0 },
                    'west':  { x: -1, y: 0, z: 0 },
                    'up':    { x: 0, y: 0, z: 1 },
                    'down':  { x: 0, y: 0, z: -1 },
                };

                room.exits?.forEach(dir => {
                    const offset = dirOffsets[dir];
                    if (!offset) return;

                    const targetRoom = visibleRooms.find(r =>
                        r.x === room.x + offset.x &&
                        r.y === room.y + offset.y &&
                        r.z === room.z + offset.z
                    );

                    if (targetRoom) {
                        const toPos = roomPositions.get(targetRoom.vnum);
                        if (toPos) {
                            // Draw connector line only once per pair
                            const pairKey = [room.vnum, targetRoom.vnum].sort().join('-');
                            if (!drawnConnectors.has(pairKey)) {
                                drawnConnectors.add(pairKey);
                                const isVertical = dir === 'up' || dir === 'down';
                                const connector = createConnector(fromPos, toPos, isVertical);
                                scene.add(connector);
                                connectorMeshes.push(connector);
                            }
                            // Exit arrow on this tile edge
                            const arrow = createExitArrow(fromPos, dir, true, isCurrentRoom);
                            if (arrow) { scene.add(arrow); connectorMeshes.push(arrow); }
                        }
                    } else {
                        // Exit leads off-screen (frontier / unexplored) ‚Äî still show arrow
                        const arrow = createExitArrow(fromPos, dir, false, isCurrentRoom);
                        if (arrow) { scene.add(arrow); connectorMeshes.push(arrow); }
                    }
                });
            });
            
            // Frontier rooms
            data.frontier?.forEach(f => {
                const geometry = new THREE.BoxGeometry(
                    CONFIG.TILE_SIZE * 0.7,
                    CONFIG.TILE_HEIGHT * 0.3,
                    CONFIG.TILE_SIZE * 0.7
                );
                const material = new THREE.MeshLambertMaterial({
                    color: f.deathtrap ? 0x660000 : 0x333344,
                    transparent: true,
                    opacity: 0.3
                });
                const mesh = new THREE.Mesh(geometry, material);
                const pos = worldToIso(f.x, f.y, f.z);
                mesh.position.copy(pos);
                mesh.userData = { frontier: true, deathtrap: f.deathtrap };
                scene.add(mesh);
                roomMeshes.set(`frontier_${f.x}_${f.y}_${f.z}`, mesh);
            });
            
            // Update player position
            if (data.player && roomPositions.has(data.player.vnum)) {
                const playerPos = roomPositions.get(data.player.vnum);
                
                if (!playerMarker) {
                    playerMarker = createPlayerMarker();
                    scene.add(playerMarker);
                }
                
                playerMarker.position.copy(playerPos);
                playerMarker.position.y += CONFIG.TILE_HEIGHT;
                
                // Update camera target
                cameraTarget.copy(playerPos);
                updateCameraPosition();
                
                if (!cameraInitialized) {
                    camera.position.copy(targetCameraPos);
                    cameraInitialized = true;
                }
                
                const room = roomData.get(data.player.vnum);
                if (room) {
                    // Boss warning when entering room with boss
                    const hasBoss = room.mobs?.some(m => classifyMob(m) === 'boss');
                    if (hasBoss && currentRoom?.vnum !== room.vnum) SFX.bossWarning();
                    else if (currentRoom?.vnum !== room.vnum) SFX.click();
                    // Clear death state when entering a new room
                    if (currentRoom?.vnum !== room.vnum) deadMobNames.clear();
                    currentRoom = room;
                    updateRoomInfo(room);
                    startAmbientSound(room.sector);
                    updatePortraitFromRoom();

                    // Update ambient particles when sector changes
                    const sector = room.sector || 'default';
                    if (sector !== _ambientSector) {
                        initAmbientParticles(sector);
                    }

                    // Update boss health bar
                    _updateBossBar(room);
                }
            }
            
            // Update minimap
            updateMinimap(data, visibleRooms);
        }
        
        function updateRoomInfo(room) {
            document.getElementById('room-name').textContent = room.name || 'Unknown';
            document.getElementById('zone-name').textContent = room.zoneName || '';
        }
        
        // ============================================
        // Minimap
        // ============================================
        
        function toggleMinimap() {
            const mm = document.getElementById('minimap');
            if (!mm) return;
            mm.classList.toggle('minimized');
        }

        function updateMinimap(data, rooms) {
            rooms = rooms || data.rooms;
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 180;
            canvas.height = 180;
            
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, 180, 180);
            
            if (!rooms || rooms.length === 0) return;
            
            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            rooms.forEach(r => {
                minX = Math.min(minX, r.x);
                maxX = Math.max(maxX, r.x);
                minY = Math.min(minY, r.y);
                maxY = Math.max(maxY, r.y);
            });
            
            const rangeX = Math.max(1, maxX - minX);
            const rangeY = Math.max(1, maxY - minY);
            const scale = Math.min(160 / rangeX, 160 / rangeY);
            const offsetX = (180 - rangeX * scale) / 2;
            const offsetY = (180 - rangeY * scale) / 2;
            
            // Draw rooms
            rooms.forEach(room => {
                const x = offsetX + (room.x - minX) * scale;
                const y = offsetY + (room.y - minY) * scale;
                const size = Math.max(4, scale * 0.8);
                
                const colors = SECTOR_COLORS[room.sector] || SECTOR_COLORS['default'];
                ctx.fillStyle = '#' + colors.top.toString(16).padStart(6, '0');
                ctx.fillRect(x - size/2, y - size/2, size, size);
            });
            
            // Draw player
            if (data.player) {
                const room = rooms.find(r => r.vnum === data.player.vnum);
                if (room) {
                    const x = offsetX + (room.x - minX) * scale;
                    const y = offsetY + (room.y - minY) * scale;
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // ============================================
        // Pathfinding
        // ============================================
        
        function findPath(startVnum, endVnum) {
            if (!allRoomsData || allRoomsData.length === 0) return [];
            
            const roomMap = new Map();
            allRoomsData.forEach(r => roomMap.set(r.vnum, r));
            
            if (!roomMap.has(startVnum) || !roomMap.has(endVnum)) return [];
            
            const visited = new Set();
            const queue = [[startVnum]];
            visited.add(startVnum);
            
            while (queue.length > 0) {
                const path = queue.shift();
                const current = path[path.length - 1];
                
                if (current === endVnum) return path;
                
                const room = roomMap.get(current);
                if (!room || !room.exits) continue;
                
                const directions = ['north', 'south', 'east', 'west', 'up', 'down'];
                const offsets = {
                    'north': { x: 0, y: -1, z: 0 },
                    'south': { x: 0, y: 1, z: 0 },
                    'east': { x: 1, y: 0, z: 0 },
                    'west': { x: -1, y: 0, z: 0 },
                    'up': { x: 0, y: 0, z: 1 },
                    'down': { x: 0, y: 0, z: -1 },
                };
                
                for (const dir of directions) {
                    if (!room.exits.includes(dir)) continue;
                    const offset = offsets[dir];
                    const neighbor = allRoomsData.find(r => 
                        r.x === room.x + offset.x &&
                        r.y === room.y + offset.y &&
                        r.z === room.z + offset.z
                    );
                    if (neighbor && !visited.has(neighbor.vnum)) {
                        visited.add(neighbor.vnum);
                        queue.push([...path, neighbor.vnum]);
                    }
                }
            }
            
            return [];
        }
        
        function getDirectionBetweenRooms(fromVnum, toVnum) {
            const from = roomData.get(fromVnum);
            const to = roomData.get(toVnum);
            if (!from || !to) return null;
            
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const dz = to.z - from.z;
            
            if (dx === 1 && dy === 0 && dz === 0) return 'east';
            if (dx === -1 && dy === 0 && dz === 0) return 'west';
            if (dx === 0 && dy === -1 && dz === 0) return 'north';
            if (dx === 0 && dy === 1 && dz === 0) return 'south';
            if (dx === 0 && dy === 0 && dz === 1) return 'up';
            if (dx === 0 && dy === 0 && dz === -1) return 'down';
            
            return null;
        }
        
        function showPath(path) {
            clearPath();
            
            path.forEach((vnum, i) => {
                if (i === 0 || i === path.length - 1) return;
                
                const mesh = roomMeshes.get(vnum);
                if (mesh) {
                    const marker = new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0xffd700 })
                    );
                    marker.position.copy(mesh.position);
                    marker.position.y += CONFIG.TILE_HEIGHT + 0.3;
                    scene.add(marker);
                    pathMeshes.push(marker);
                }
            });
        }
        
        function clearPath() {
            pathMeshes.forEach(m => scene.remove(m));
            pathMeshes = [];
            currentPath = [];
            isAutoWalking = false;
        }
        
        async function walkPath(path) {
            if (path.length < 2) return;
            
            isAutoWalking = true;
            currentPath = path;
            showPath(path);
            
            for (let i = 1; i < path.length && isAutoWalking; i++) {
                const dir = getDirectionBetweenRooms(path[i-1], path[i]);
                if (dir) {
                    sendCommand(dir);
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            clearPath();
        }
        
        // ============================================
        // Interaction
        // ============================================
        
        function onCanvasClick(event) {
            if (isDragging) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const meshArray = Array.from(roomMeshes.values()).filter(m => !m.userData.frontier);
            const intersects = raycaster.intersectObjects(meshArray, false);
            
            if (intersects.length > 0) {
                const clicked = intersects[0].object;
                if (clicked.userData.vnum && clicked.userData.room && currentRoom) {
                    const targetRoom = clicked.userData.room;
                    
                    // Find path
                    const path = findPath(currentRoom.vnum, targetRoom.vnum);
                    if (path.length > 1) {
                        walkPath(path);
                    }
                }
            }
        }
        
        function onCanvasHover(event) {
            if (isDragging) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const meshArray = Array.from(roomMeshes.values());
            const intersects = raycaster.intersectObjects(meshArray, true);
            
            const tooltip = document.getElementById('tooltip');
            
            if (intersects.length > 0) {
                const hit = intersects[0].object;
                
                // Check mob marker
                let current = hit;
                while (current) {
                    if (current.userData?.mob) {
                        const mob = current.userData.mob;
                        tooltip.innerHTML = `
                            <div class="mob-name">${mob.name || 'A creature'}${mob.hostile ? '<span class="hostile-tag">‚ö† HOSTILE</span>' : ''}</div>
                            <div class="mob-level">Level ${mob.level || '??'}</div>
                            ${mob.hp !== undefined ? `<div class="mob-hp"><div class="mob-hp-fill" style="width:${(mob.hp/mob.maxHp)*100}%"></div></div>` : ''}
                        `;
                        tooltip.style.display = 'block';
                        tooltip.style.left = event.clientX + 15 + 'px';
                        tooltip.style.top = event.clientY + 15 + 'px';
                        return;
                    }
                    current = current.parent;
                }
                
                // Room hover
                if (hit.userData?.room) {
                    const room = hit.userData.room;
                    const mobNames = room.mobs?.map(m => m.name) || [];
                    const mobList = mobNames.slice(0, 3).join(', ');
                    const hostileCount = (room.mobs || []).filter(m => m.hostile).length;
                    const exits = (room.exits || []).map(e => {
                const k = (e || '').toLowerCase();
                if (['north','south','east','west','up','down'].includes(k)) return k[0].toUpperCase();
                return e;
            }).join(' ') || '‚Äî';
                    const oneWay = (room.oneWayExits || []).map(e => e[0].toUpperCase()).join(' ');
                    const flags = (room.flags || []).map(f => f.replace(/_/g,' '));
                    const hazard = flags.includes('deathtrap') ? '‚ò† Deathtrap' : '';
                    const sector = room.sector?.replace(/_/g,' ') || 'unknown';

                    if (room.vnum !== currentRoom?.vnum) {
                        tooltip.innerHTML = `
                            <div class="mob-name">${room.name}</div>
                            <div style="color:#999;font-size:11px;margin-top:4px">Sector: ${sector}</div>
                            <div style="color:#aaa;font-size:11px;margin-top:2px">Exits: ${exits}${oneWay ? ` <span style=\"color:#d8a\">(one-way: ${oneWay})</span>` : ''}</div>
                            ${hazard ? `<div style="color:#ff7777;font-size:11px;margin-top:2px">${hazard}</div>` : ''}
                            ${mobList ? `<div style="color:#888;font-size:11px;margin-top:5px">Mobs: ${mobList}${mobNames.length > 3 ? '...' : ''}${hostileCount ? ` <span style=\"color:#ff8888\">(${hostileCount} hostile)</span>` : ''}</div>` : ''}
                        `;
                        tooltip.style.display = 'block';
                        tooltip.style.left = event.clientX + 15 + 'px';
                        tooltip.style.top = event.clientY + 15 + 'px';
                        return;
                    }
                }
            }
            
            tooltip.style.display = 'none';
        }
        
        // ============================================
        // Stats Parsing
        // ============================================
        
        function parseStats(text) {
            // Parse HP/Mana/Move from prompt or score output
            // Example: "100H 50M 75V >"
            const hpMatch = text.match(/(\d+)\/(\d+)\s*[Hh][Pp]?|(\d+)[Hh]\b/);
            const manaMatch = text.match(/(\d+)\/(\d+)\s*[Mm](?:ana)?|(\d+)[Mm]\b/);
            const moveMatch = text.match(/(\d+)\/(\d+)\s*[Vv]|(\d+)[Vv]\b/);
            
            if (hpMatch) {
                if (hpMatch[1] && hpMatch[2]) {
                    playerStats.hp = parseInt(hpMatch[1]);
                    playerStats.maxHp = parseInt(hpMatch[2]);
                } else if (hpMatch[3]) {
                    playerStats.hp = parseInt(hpMatch[3]);
                }
            }
            
            if (manaMatch) {
                if (manaMatch[1] && manaMatch[2]) {
                    playerStats.mana = parseInt(manaMatch[1]);
                    playerStats.maxMana = parseInt(manaMatch[2]);
                } else if (manaMatch[3]) {
                    playerStats.mana = parseInt(manaMatch[3]);
                }
            }
            
            if (moveMatch) {
                if (moveMatch[1] && moveMatch[2]) {
                    playerStats.move = parseInt(moveMatch[1]);
                    playerStats.maxMove = parseInt(moveMatch[2]);
                } else if (moveMatch[3]) {
                    playerStats.move = parseInt(moveMatch[3]);
                }
            }
            
            updateStatsDisplay();
            
            // Check combat ‚Äî broad detection
            if (/fighting YOU|you are fighting|combat begins|you engage|attacks you|is here, fighting/i.test(text)) {
                setCombatState(true);
            } else if (/you have stopped fighting|you flee|is dead!|is slain!|combat over/i.test(text)) {
                setCombatState(false);
            }
        }
        
        function updateStatusEffects(p) {
            const wrap = document.getElementById('status-effects');
            if (!wrap || !p) return;
            const affects = p.affects || [];
            if (!affects.length) { wrap.innerHTML = ''; return; }

            const debuffFlags = new Set(['poisoned','blind','stunned','paralyzed','feared','slow','silenced','diseased','marked','curse','bleed']);

            const pills = affects.slice(0, 8).map(a => {
                const name = (a.name || a.applies_to || 'Effect').replace(/_/g,' ');
                const isDebuff = (a.value < 0) || debuffFlags.has((a.applies_to||'').toLowerCase()) || debuffFlags.has((a.name||'').toLowerCase());
                const cls = isDebuff ? 'debuff' : 'buff';
                const remaining = (a.remaining !== undefined) ? a.remaining : null;
                const dur = remaining !== null ? `<span class="dur">${remaining}</span>` : '';
                return `<div class="effect-pill ${cls}">${name}${dur}</div>`;
            }).join('');

            const extra = affects.length > 8 ? `<div class="effect-pill">+${affects.length - 8}</div>` : '';
            wrap.innerHTML = pills + extra;
        }

        function updateStatsDisplay() {
            const hpPct = playerStats.maxHp > 0 ? (playerStats.hp / playerStats.maxHp) : 1;
            document.getElementById('hp-fill').style.width = `${hpPct * 100}%`;
            document.getElementById('hp-text').textContent = `${playerStats.hp}/${playerStats.maxHp}`;

            // Low HP danger state: bar pulse + vignette
            const hpBar = document.querySelector('.stat-bar-hp');
            const vignette = document.getElementById('danger-vignette');
            const isDanger = hpPct <= 0.25 && playerStats.maxHp > 0;
            hpBar?.classList.toggle('danger', isDanger);
            vignette?.classList.toggle('active', isDanger);

            document.getElementById('mana-fill').style.width = `${(playerStats.mana / playerStats.maxMana) * 100}%`;
            document.getElementById('mana-text').textContent = `${playerStats.mana}/${playerStats.maxMana}`;

            document.getElementById('move-fill').style.width = `${(playerStats.move / playerStats.maxMove) * 100}%`;
            document.getElementById('move-text').textContent = `${playerStats.move}/${playerStats.maxMove}`;
        }
        
        // ============================================
        // DCSS Sprite Lookup
        // ============================================

        // Name keyword ‚Üí DCSS sprite path (ordered longest-match first)
        const DCSS_NAME_MAP = [
            // --- Multi-word exact matches first (most specific) ---
            ['the spider queen',        'dcss/boss/arachne.png'],
            ['spider queen',            'dcss/boss/arachne.png'],
            ['the necromancer',         'dcss/undead/ancient_lich.png'],
            ['ancient treant',          'dcss/fungi_plants/treant.png'],
            ['web spinner',             'dcss/animals/broodmother.png'],
            ['cryohydra',               'dcss/dragons/hydra.png'],
            ['lernaean hydra',          'dcss/dragons/hydra.png'],
            ['hell hound',              'dcss/animals/hell_hound.png'],
            ['great orb of eyes',       'dcss/eyes/great_orb_of_eyes.png'],
            ['master mindflayer',       'dcss/aberrations/tentacled_monstrosity.png'],
            ['tentacled monstrosity',   'dcss/aberrations/tentacled_monstrosity.png'],
            ['skeletal warrior',        'dcss/undead/skeletal_warrior.png'],
            ['blazeheart golem',        'dcss/golems/blazeheart_golem.png'],
            ['vampire mosquito',        'dcss/animals/vampire_mosquito.png'],
            ['gnoll sergeant',          'dcss/humanoids/gnoll_sergeant.png'],
            ['gnoll shaman',            'dcss/humanoids/gnoll_shaman.png'],
            ['electric golem',          'dcss/golems/electric_golem.png'],
            ['guardian sphinx',         'dcss/demihumanoids/guardian_sphinx.png'],
            ['giant cockroach',         'dcss/animals/giant_cockroach.png'],
            ['crystallized elemental',  'dcss/nonliving/crystal_guardian.png'],
            ['crystal elemental',       'dcss/nonliving/crystal_guardian.png'],
            ['goblin berserker',        'dcss/humanoids/goblin.png'],
            ['goblin shaman',           'dcss/humanoids/gnoll_shaman.png'],
            ['goblin king',             'dcss/humanoids/goblin.png'],
            ['kobold brigand',          'dcss/humanoids/kobold_brigand.png'],
            ['emperor scorpion',        'dcss/animals/emperor_scorpion.png'],
            ['water elemental',         'dcss/elementals/water_elemental.png'],
            ['ancient lich',            'dcss/undead/ancient_lich.png'],
            ['earth elemental',         'dcss/elementals/earth_elemental.png'],
            ['fire elemental',          'dcss/elementals/fire_elemental.png'],
            ['ice elemental',           'dcss/elementals/water_elemental.png'],
            ['iron elemental',          'dcss/elementals/iron_elemental.png'],
            ['air elemental',           'dcss/elementals/air_elemental.png'],
            ['mind flayer',             'dcss/aberrations/tentacled_monstrosity.png'],
            ['ice dragon',              'dcss/dragons/ice_dragon.png'],
            ['bone dragon',             'dcss/undead/bone_dragon.png'],
            ['fire dragon',             'dcss/dragons/fire_dragon.png'],
            ['fire bat',                'dcss/animals/fire_bat.png'],
            ['frost giant',             'dcss/giants/frost_giant.png'],
            ['golden dragon',           'dcss/dragons/golden_dragon.png'],
            ['jumping spider',          'dcss/animals/jumping_spider.png'],
            ['komodo dragon',           'dcss/animals/komodo_dragon.png'],
            ['mummy priest',            'dcss/undead/mummy_priest.png'],
            ['orc warrior',             'dcss/humanoids/orc_warrior.png'],
            ['orc knight',              'dcss/humanoids/orc_knight.png'],
            ['shadow demon',            'dcss/demons/shadow_demon.png'],
            ['shadow dragon',           'dcss/dragons/shadow_dragon.png'],
            ['shadow wraith',           'dcss/undead/shadow_wraith.png'],
            ['shadow bat',              'dcss/animals/bat.png'],
            ['shadow lord',             'dcss/undead/shadow_wraith.png'],
            ['storm dragon',            'dcss/dragons/storm_dragon.png'],
            ['stone giant',             'dcss/giants/stone_giant.png'],
            ['swamp worm',              'dcss/aquatic/swamp_worm.png'],
            ['vampire knight',          'dcss/undead/vampire_knight.png'],
            ['vampire bat',             'dcss/animals/vampire_bat.png'],
            ['vampire mage',            'dcss/undead/vampire.png'],
            ['volcanic drake',          'dcss/dragons/fire_dragon.png'],
            ['water nymph',             'dcss/humanoids/water_nymph.png'],
            ['will-o-wisp',             'dcss/nonliving/will_o_the_wisp.png'],
            ['will o wisp',             'dcss/nonliving/will_o_the_wisp.png'],
            ['zombie gnoll',            'dcss/undead/zombie_gnoll.png'],
            ['zombie troll',            'dcss/undead/zombie_troll.png'],
            ['black mamba',             'dcss/animals/black_mamba.png'],
            ['black bear',              'dcss/animals/black_bear.png'],
            ['polar bear',              'dcss/animals/polar_bear.png'],
            ['cave troll',              'dcss/humanoids/troll.png'],
            ['cave spider',             'dcss/animals/wolf_spider.png'],
            ['chaos spawn',             'dcss/demons/chaos_spawn1.png'],
            ['clockwork soldier',       'dcss/golems/electric_golem.png'],
            ['crystal guardian',        'dcss/nonliving/crystal_guardian.png'],
            ['death yak',               'dcss/animals/death_yak.png'],
            ['deep troll',              'dcss/humanoids/deep_troll.png'],
            ['dire wolf',               'dcss/animals/wolf.png'],
            ['drowned soul',            'dcss/undead/drowned_soul.png'],
            ['electric eel',            'dcss/aquatic/electric_eel.png'],
            ['fire giant',              'dcss/giants/fire_giant.png'],
            ['forest sprite',           'dcss/humanoids/dryad.png'],
            ['forest wolf',             'dcss/animals/wolf.png'],
            ['forest deer',             'dcss/animals/catoblepas.png'],
            ['freezing wraith',         'dcss/undead/freezing_wraith.png'],
            ['frost wolf',              'dcss/animals/wolf.png'],
            ['frozen ghoul',            'dcss/undead/ghoul.png'],
            ['giant bee',               'dcss/animals/killer_bee.png'],
            ['giant crab',              'dcss/animals/catoblepas.png'],
            ['giant spider',            'dcss/animals/wolf_spider.png'],
            ['giant sewer rat',         'dcss/animals/rat.png'],
            ['green snake',             'dcss/animals/adder.png'],
            ['sewer snake',             'dcss/animals/adder.png'],
            ['sewer bat',               'dcss/animals/bat.png'],
            ['sewer rat',               'dcss/animals/rat.png'],
            ['sewer hag',               'dcss/undead/ghoul.png'],
            ['sewer king',              'dcss/aberrations/tentacled_monstrosity.png'],
            ['ice troll',               'dcss/humanoids/troll.png'],
            ['ice wraith',              'dcss/undead/freezing_wraith.png'],
            ['iron golem',              'dcss/golems/iron_golem.png'],
            ['flesh golem',             'dcss/golems/flesh_golem.png'],
            ['steam golem',             'dcss/golems/iron_golem.png'],
            ['killer bee',              'dcss/animals/killer_bee.png'],
            ['mirror wraith',           'dcss/undead/wraith.png'],
            ['ash wraith',              'dcss/undead/wraith.png'],
            ['orange rat',              'dcss/animals/orange_rat.png'],
            ['ogre mage',               'dcss/humanoids/ogre_mage.png'],
            ['pit fiend',               'dcss/demons/balrug.png'],
            ['pitbeast',                'dcss/demons/balrug.png'],
            ['red devil',               'dcss/demons/red_devil.png'],
            ['ice devil',               'dcss/demons/ice_devil.png'],
            ['sea serpent',             'dcss/animals/anaconda.png'],
            ['sea snake',               'dcss/animals/anaconda.png'],
            ['sea witch',               'dcss/humanoids/water_nymph.png'],
            ['slime creature',          'dcss/amorphous/slime_creature.png'],
            ['stray dog',               'dcss/animals/hound.png'],
            ['war dog',                 'dcss/animals/hound.png'],
            ['trained war',             'dcss/animals/hound.png'],
            ['wolf spider',             'dcss/animals/wolf_spider.png'],
            ['sun demon',               'dcss/demons/sun_demon.png'],
            ['soul eater',              'dcss/demons/soul_eater.png'],
            ['death knight',            'dcss/undead/revenant.png'],
            ['dracolich',               'dcss/undead/bone_dragon.png'],
            ['void walker',             'dcss/undead/shadow_wraith.png'],
            ['mountain lion',           'dcss/animals/catoblepas.png'],
            ['alpha wolf',              'dcss/animals/wolf.png'],
            ['timber wolf',             'dcss/animals/wolf.png'],
            ['highland raider',         'dcss/humanoids/kobold_brigand.png'],
            ['highland hermit',         'dcss/humanoids/dryad.png'],
            ['forest bandit',           'dcss/humanoids/kobold_brigand.png'],
            ['forest hermit',           'dcss/humanoids/dryad.png'],
            ['bandit leader',           'dcss/humanoids/kobold_brigand.png'],
            ['bandit captain',          'dcss/humanoids/kobold_brigand.png'],
            ['pirate captain',          'dcss/humanoids/kobold_brigand.png'],
            ['goblin guard',            'dcss/humanoids/goblin.png'],
            ['goblin merchant',         'dcss/humanoids/goblin.png'],
            ['goblin farmer',           'dcss/humanoids/goblin.png'],
            ['goblin scout',            'dcss/humanoids/goblin.png'],
            ['drow child',              'dcss/humanoids/goblin.png'],
            ['shadow assassin',         'dcss/undead/shadow_wraith.png'],
            ['shadow stalker',          'dcss/undead/shadow_wraith.png'],
            ['restless ghost',          'dcss/undead/ghost.png'],
            ['restless monk',           'dcss/undead/phantom.png'],
            ['spectral priest',         'dcss/undead/phantom.png'],
            ['spectral librarian',      'dcss/undead/phantom.png'],
            ['undead guardian',         'dcss/undead/revenant.png'],
            ['possessed armor',         'dcss/golems/iron_golem.png'],
            ['tesla coil',              'dcss/golems/electric_golem.png'],
            ['repair drone',            'dcss/golems/electric_golem.png'],
            ['clock soldier',           'dcss/golems/electric_golem.png'],
            ['magma crawler',           'dcss/elementals/fire_elemental.png'],
            ['stick stalker',           'dcss/humanoids/dryad.png'],
            ['nightmare beast',         'dcss/demons/cacodemon.png'],
            // --- Dragons ---
            ['aurexus',                 'dcss/dragons/golden_dragon.png'],
            ['kaleidos',                'dcss/dragons/golden_dragon.png'],
            ['scorathax',               'dcss/dragons/fire_dragon.png'],
            ['verdraxx',                'dcss/dragons/shadow_dragon.png'],
            ['vyrkothas',               'dcss/dragons/ice_dragon.png'],
            ['yevaud',                  'dcss/dragons/fire_dragon.png'],
            ['puff',                    'dcss/dragons/golden_dragon.png'],
            ['dragon',                  'dcss/dragons/fire_dragon.png'],
            ['wyvern',                  'dcss/dragons/fire_dragon.png'],
            ['drake',                   'dcss/dragons/fire_dragon.png'],
            ['wyrm',                    'dcss/dragons/fire_dragon.png'],
            // --- Undead ---
            ['vampire',                 'dcss/undead/vampire.png'],
            ['lich',                    'dcss/undead/lich.png'],
            ['mummy',                   'dcss/undead/mummy.png'],
            ['ghoul',                   'dcss/undead/ghoul.png'],
            ['ghast',                   'dcss/undead/necrophage.png'],
            ['ghost',                   'dcss/undead/ghost.png'],
            ['zombie',                  'dcss/undead/zombie_gnoll.png'],
            ['skeleton',                'dcss/undead/skeletal_warrior.png'],
            ['wight',                   'dcss/undead/wight.png'],
            ['wraith',                  'dcss/undead/wraith.png'],
            ['spectre',                 'dcss/undead/phantom.png'],
            ['specter',                 'dcss/undead/phantom.png'],
            ['phantom',                 'dcss/undead/phantom.png'],
            ['shade',                   'dcss/undead/shadow_wraith.png'],
            ['revenant',                'dcss/undead/revenant.png'],
            ['necrophage',              'dcss/undead/necrophage.png'],
            ['drowned',                 'dcss/undead/drowned_soul.png'],
            ['poltergeist',             'dcss/undead/poltergeist.png'],
            ['charred',                 'dcss/undead/skeletal_warrior.png'],
            ['bone',                    'dcss/undead/bone_dragon.png'],
            // --- Demons ---
            ['executioner',             'dcss/demons/executioner.png'],
            ['balrog',                  'dcss/demons/balrug.png'],
            ['balur',                   'dcss/demons/balrug.png'],
            ['balor',                   'dcss/demons/balrug.png'],
            ['efreeti',                 'dcss/demons/efreet.png'],
            ['efreet',                  'dcss/demons/efreet.png'],
            ['djinn',                   'dcss/demons/efreet.png'],
            ['jinn',                    'dcss/demons/efreet.png'],
            ['reaper',                  'dcss/demons/reaper.png'],
            ['demon',                   'dcss/demons/balrug.png'],
            ['devil',                   'dcss/demons/red_devil.png'],
            ['fiend',                   'dcss/demons/balrug.png'],
            ['imp',                     'dcss/demons/red_devil.png'],
            ['succubus',                'dcss/demons/soul_eater.png'],
            ['incubus',                 'dcss/demons/soul_eater.png'],
            ['lemure',                  'dcss/demons/lemure.png'],
            ['quasit',                  'dcss/demons/red_devil.png'],
            ['iblis',                   'dcss/demons/efreet.png'],
            ['cacodemon',               'dcss/demons/cacodemon.png'],
            ['homunculus',              'dcss/demons/chaos_spawn1.png'],
            // --- Giants ---
            ['cyclops',                 'dcss/giants/cyclops.png'],
            ['titan',                   'dcss/giants/titan.png'],
            ['giant',                   'dcss/giants/stone_giant.png'],
            // --- Golems / Constructs ---
            ['gargoyle',                'dcss/golems/gargoyle.png'],
            ['golem',                   'dcss/golems/iron_golem.png'],
            ['automaton',               'dcss/golems/electric_golem.png'],
            ['construct',               'dcss/golems/iron_golem.png'],
            ['statue',                  'dcss/golems/iron_golem.png'],
            // --- Elementals ---
            ['elemental',               'dcss/elementals/fire_elemental.png'],
            ['magma',                   'dcss/elementals/fire_elemental.png'],
            ['frozen',                  'dcss/elementals/water_elemental.png'],
            ['frost',                   'dcss/elementals/water_elemental.png'],
            ['aerial',                  'dcss/elementals/air_elemental.png'],
            // --- Holy ---
            ['seraph',                  'dcss/holy/seraph.png'],
            ['cherub',                  'dcss/holy/cherub.png'],
            ['daeva',                   'dcss/holy/daeva.png'],
            ['angel',                   'dcss/holy/angel.png'],
            ['ki-rin',                  'dcss/holy/angel.png'],
            ['archon',                  'dcss/holy/seraph.png'],
            ['couatl',                  'dcss/demihumanoids/salamander.png'],
            // --- Demihumanoids ---
            ['minotaur',                'dcss/demihumanoids/minotaur.png'],
            ['minos',                   'dcss/demihumanoids/minotaur.png'],
            ['harpy',                   'dcss/demihumanoids/harpy.png'],
            ['androsphinx',             'dcss/demihumanoids/guardian_sphinx.png'],
            ['gynosphinx',              'dcss/demihumanoids/guardian_sphinx.png'],
            ['criosphinx',              'dcss/demihumanoids/guardian_sphinx.png'],
            ['hieracosphinx',           'dcss/demihumanoids/guardian_sphinx.png'],
            ['sphinx',                  'dcss/demihumanoids/guardian_sphinx.png'],
            ['drider',                  'dcss/demons/cacodemon.png'],
            ['salamander',              'dcss/demihumanoids/salamander.png'],
            ['naga',                    'dcss/demihumanoids/salamander.png'],
            ['faun',                    'dcss/demihumanoids/faun.png'],
            // --- Humanoids ---
            ['guildmaster',             'dcss/humanoids/orc_knight.png'],
            ['hobgoblin',               'dcss/humanoids/hobgoblin.png'],
            ['kobold',                  'dcss/humanoids/kobold.png'],
            ['goblin',                  'dcss/humanoids/goblin.png'],
            ['drow',                    'dcss/humanoids/kobold_brigand.png'],
            ['duergar',                 'dcss/humanoids/dwarf.png'],
            ['dwarf',                   'dcss/humanoids/dwarf.png'],
            ['gnoll',                   'dcss/humanoids/gnoll.png'],
            ['ogre',                    'dcss/humanoids/ogre.png'],
            ['troll',                   'dcss/humanoids/troll.png'],
            ['orc',                     'dcss/humanoids/orc.png'],
            ['dryad',                   'dcss/humanoids/dryad.png'],
            ['nymph',                   'dcss/humanoids/water_nymph.png'],
            ['sahuagin',                'dcss/humanoids/water_nymph.png'],
            ['mermaid',                 'dcss/humanoids/water_nymph.png'],
            ['merman',                  'dcss/humanoids/water_nymph.png'],
            ['merfolk',                 'dcss/humanoids/water_nymph.png'],
            ['lamia',                   'dcss/demihumanoids/salamander.png'],
            ['bandit',                  'dcss/humanoids/kobold_brigand.png'],
            ['brigand',                 'dcss/humanoids/kobold_brigand.png'],
            ['pickpocket',              'dcss/humanoids/kobold_brigand.png'],
            ['rogue',                   'dcss/humanoids/kobold_brigand.png'],
            // --- Animals: Bats ---
            ['bat',                     'dcss/animals/bat.png'],
            // --- Animals: Rats / Wererats ---
            ['wererat',                 'dcss/animals/rat.png'],
            ['rat',                     'dcss/animals/rat.png'],
            // --- Animals: Snakes ---
            ['cobra',                   'dcss/animals/adder.png'],
            ['asp',                     'dcss/animals/adder.png'],
            ['adder',                   'dcss/animals/adder.png'],
            ['anaconda',                'dcss/animals/anaconda.png'],
            ['serpent',                 'dcss/animals/adder.png'],
            ['snake',                   'dcss/animals/adder.png'],
            // --- Animals: Arachnids ---
            ['scorpion',                'dcss/animals/scorpion.png'],
            ['spider',                  'dcss/animals/wolf_spider.png'],
            // --- Animals: Reptiles ---
            ['crocodile',               'dcss/animals/crocodile.png'],
            ['alligator',               'dcss/animals/alligator.png'],
            ['iguana',                  'dcss/animals/iguana.png'],
            ['lizard',                  'dcss/animals/iguana.png'],
            ['basilisk',                'dcss/animals/basilisk.png'],
            ['komodo',                  'dcss/animals/komodo_dragon.png'],
            // --- Animals: Insects ---
            ['wasp',                    'dcss/animals/hornet.png'],
            ['hornet',                  'dcss/animals/hornet.png'],
            ['bee',                     'dcss/animals/killer_bee.png'],
            ['mosquito',                'dcss/animals/vampire_mosquito.png'],
            ['cockroach',               'dcss/animals/giant_cockroach.png'],
            ['centipede',               'dcss/animals/giant_cockroach.png'],
            ['beetle',                  'dcss/animals/giant_cockroach.png'],
            ['roach',                   'dcss/animals/giant_cockroach.png'],
            // --- Animals: Canines ---
            ['wolf',                    'dcss/animals/wolf.png'],
            ['warg',                    'dcss/animals/warg.png'],
            ['jackal',                  'dcss/animals/jackal.png'],
            ['hound',                   'dcss/animals/hound.png'],
            ['rottweiler',              'dcss/animals/hound.png'],
            ['beagle',                  'dcss/animals/hound.png'],
            ['puppy',                   'dcss/animals/hound.png'],
            ['fido',                    'dcss/animals/hound.png'],
            ['dog',                     'dcss/animals/hound.png'],
            // --- Animals: Felines (custom art) ---
            // --- Animals: Bears ---
            ['bear',                    'dcss/animals/black_bear.png'],
            // --- Animals: Birds ---
            ['raven',                   'dcss/animals/raven.png'],
            ['crow',                    'dcss/animals/raven.png'],
            ['hawk',                    'dcss/animals/raven.png'],
            ['eagle',                   'dcss/animals/raven.png'],
            ['vulture',                 'dcss/animals/raven.png'],
            ['sparrow',                 'dcss/animals/raven.png'],
            ['bird',                    'dcss/animals/raven.png'],
            // --- Animals: Ungulates / Large ---
            ['boar',                    'dcss/animals/hog.png'],
            ['hog',                     'dcss/animals/hog.png'],
            ['pig',                     'dcss/animals/hog.png'],
            ['horse',                   'dcss/animals/horse.png'],
            ['deer',                    'dcss/animals/deer.png'],
            ['goat',                    'dcss/animals/catoblepas.png'],
            ['camel',                   'dcss/animals/catoblepas.png'],
            ['yak',                     'dcss/animals/death_yak.png'],
            // --- Animals: Misc ---
            ['manticore',               'dcss/animals/manticore.png'],
            ['hippogriff',              'dcss/animals/hippogriff.png'],
            ['pegasus',                 'dcss/animals/horse.png'],
            ['chimera',                 'dcss/animals/chimera.png'],
            ['catoblepas',              'dcss/animals/catoblepas.png'],
            ['worm',                    'dcss/aquatic/swamp_worm.png'],
            ['maggot',                  'dcss/aquatic/swamp_worm.png'],
            ['slug',                    'dcss/aquatic/swamp_worm.png'],
            ['crawler',                 'dcss/aquatic/swamp_worm.png'],
            // --- Aquatic ---
            ['kraken',                  'dcss/aquatic/kraken_head.png'],
            ['leviathan',               'dcss/aquatic/kraken_head.png'],
            ['shark',                   'dcss/aquatic/kraken_head.png'],
            ['octopus',                 'dcss/aquatic/octopode.png'],
            ['octopode',                'dcss/aquatic/octopode.png'],
            ['eel',                     'dcss/aquatic/electric_eel.png'],
            ['jellyfish',               'dcss/aquatic/jellyfish.png'],
            ['fish',                    'dcss/aquatic/jellyfish.png'],
            ['crab',                    'dcss/animals/catoblepas.png'],
            ['turtle',                  'dcss/animals/catoblepas.png'],
            // --- Amorphous / Slimes ---
            ['slime',                   'dcss/amorphous/slime_creature.png'],
            ['ooze',                    'dcss/amorphous/slime_creature.png'],
            ['blob',                    'dcss/amorphous/slime_creature.png'],
            ['jelly',                   'dcss/amorphous/jelly.png'],
            ['shapeshifter',            'dcss/amorphous/shapeshifter.png'],
            ['mimic',                   'dcss/amorphous/shapeshifter.png'],
            ['mudmonster',              'dcss/amorphous/slime_creature.png'],
            // --- Mindflayers ---
            ['mindflayer',              'dcss/aberrations/tentacled_monstrosity.png'],
            ['flayer',                  'dcss/aberrations/tentacled_monstrosity.png'],
            ['beholder',                'dcss/eyes/great_orb_of_eyes.png'],
            ['great orb',               'dcss/eyes/great_orb_of_eyes.png'],
            ['orb of eyes',             'dcss/eyes/great_orb_of_eyes.png'],
            ['morkoth',                 'dcss/aberrations/tentacled_monstrosity.png'],
            ['horror',                  'dcss/aberrations/tentacled_monstrosity.png'],
            ['behir',                   'dcss/aberrations/tentacled_monstrosity.png'],
            ['ixitxachitl',             'dcss/aquatic/jellyfish.png'],
            // --- Aberrations / Mutants ---
            ['otyugh',                  'dcss/aberrations/ugly_thing.png'],
            ['abomination',             'dcss/aberrations/abomination_large.png'],
            ['ugly thing',              'dcss/aberrations/ugly_thing.png'],
            ['grotesque',               'dcss/aberrations/abomination_large.png'],
            ['mutant',                  'dcss/aberrations/ugly_thing.png'],
            // --- Fungi / Plants ---
            ['myconoid',                'dcss/fungi_plants/wandering_mushroom.png'],
            ['mushroom',                'dcss/fungi_plants/wandering_mushroom.png'],
            ['fungus',                  'dcss/fungi_plants/wandering_mushroom.png'],
            ['toadstool',               'dcss/fungi_plants/toadstool.png'],
            ['treant',                  'dcss/fungi_plants/treant.png'],
            ['ancient treant',          'dcss/fungi_plants/treant.png'],
            ['tree',                    'dcss/fungi_plants/treant.png'],
            // --- Hydra ---
            ['cryohydra',               'dcss/dragons/hydra.png'],
            ['lernaean',                'dcss/dragons/hydra.png'],
            ['hydra',                   'dcss/dragons/hydra.png'],
            // --- Spider Queen / Bosses ---
            ['spider queen',            'dcss/boss/arachne.png'],
            ['the spider queen',        'dcss/boss/arachne.png'],
            ['arachne',                 'dcss/boss/arachne.png'],
            ['broodmother',             'dcss/animals/broodmother.png'],
            ['web spinner',             'dcss/animals/broodmother.png'],
            ['yochlol',                 'dcss/demihumanoids/jorogumo.png'],
            ['jorogumo',                'dcss/demihumanoids/jorogumo.png'],
            ['drider',                  'dcss/demihumanoids/jorogumo.png'],
            // --- Named Bosses ---
            ['kirgan',                  'dcss/boss/kirgan.png'],
            ['shadow lord malachar',    'dcss/boss/shadow_lord.png'],
            ['shadow lord',             'dcss/boss/shadow_lord.png'],
            ['malachar',                'dcss/boss/shadow_lord.png'],
            ['goblin king grizznak',    'dcss/boss/goblin_king.png'],
            ['grizznak',                'dcss/boss/goblin_king.png'],
            ['the necromancer',         'dcss/undead/ancient_lich.png'],
            ['pharoah',                 'dcss/boss/khufu.png'],
            ['pharaoh',                 'dcss/boss/khufu.png'],
            ['ramses',                  'dcss/boss/khufu.png'],
            ['khufu',                   'dcss/boss/khufu.png'],
            // --- Four Horsemen ---
            ['horseman of death',       'dcss/boss/horseman_death.png'],
            ['horseman of war',         'dcss/boss/horseman_war.png'],
            ['horseman of famine',      'dcss/boss/horseman_famine.png'],
            ['horseman of pestilence',  'dcss/boss/horseman_pestilence.png'],
            // --- Small Animals (see custom art section below) ---
            // --- Felines (custom art) ---
            ['lion',                    'dcss/animals/lion.png'],
            ['tiger',                   'dcss/animals/tiger.png'],
            ['bobcat',                  'dcss/animals/lion.png'],
            ['panther',                 'dcss/animals/tiger.png'],
            ['mountain lion',           'dcss/animals/lion.png'],
            ['cat',                     'dcss/animals/lion.png'],
            ['tabby',                   'dcss/animals/lion.png'],
            ['kitten',                  'dcss/animals/lion.png'],
            // --- Mustelids (custom art) ---
            ['wolverine',               'dcss/animals/wolverine.png'],
            ['badger',                  'dcss/animals/badger.png'],
            // --- Fox (custom art) ---
            ['fox',                     'dcss/animals/fox.png'],
            ['inugami',                 'dcss/animals/fox.png'],
            // --- Small woodland creatures (custom art) ---
            ['rabbit',                  'dcss/animals/rabbit.png'],
            ['squirrel',                'dcss/animals/squirrel.png'],
            ['chipmunk',                'dcss/animals/squirrel.png'],
            ['mongoose',                'dcss/animals/squirrel.png'],
            ['quokka',                  'dcss/animals/rabbit.png'],
            ['ferret',                  'dcss/animals/rabbit.png'],
            ['otter',                   'dcss/animals/rabbit.png'],
            // --- Deer (custom art) ---
            ['deer',                    'dcss/animals/deer.png'],
            ['stag',                    'dcss/animals/deer.png'],
            ['fawn',                    'dcss/animals/deer.png'],
            // --- Waterfowl (custom art) ---
            ['swan',                    'dcss/animals/swan.png'],
            ['duck',                    'dcss/animals/duck.png'],
            ['duckling',                'dcss/animals/duck.png'],
            // --- Horse (custom art) ---
            ['horse',                   'dcss/animals/horse.png'],
            ['pegasus',                 'dcss/animals/horse.png'],
            // --- Chimera (custom art) ---
            ['chimera',                 'dcss/animals/chimera.png'],
            // --- Frogs ---
            ['frog',                    'dcss/animals/bullfrog.png'],
            ['toad',                    'dcss/animals/bullfrog.png'],
            // --- Elephant ---
            ['elephant',                'dcss/animals/elephant.png'],
            // --- Hell hound ---
            ['hell hound',              'dcss/animals/hell_hound.png'],
            ['hellhound',               'dcss/animals/hell_hound.png'],
            // --- Satyr ---
            ['satyr',                   'dcss/demihumanoids/satyr.png'],
        ];


        // Type fallbacks when name doesn't match
        const DCSS_TYPE_FALLBACK = {
            dragon:     'dcss/dragons/fire_dragon.png',
            undead:     'dcss/undead/skeletal_warrior.png',
            demon:      'dcss/demons/balrug.png',
            beast:      'dcss/animals/wolf.png',
            humanoid:   'dcss/humanoids/orc_warrior.png',
            elemental:  'dcss/elementals/fire_elemental.png',
            boss:       'dcss/boss/dragon_boss.png',
            friendly:   'dcss/holy/angel.png',
            shopkeeper: 'sprites/shopkeeper.png',
        };

        // Exact name ‚Üí sprite (for single-word named bosses/NPCs where partial matching would bleed)
        const DCSS_EXACT_NAME_MAP = {
            'death':                    'dcss/boss/horseman_death.png',
            'war':                      'dcss/boss/horseman_war.png',
            'famine':                   'dcss/boss/horseman_famine.png',
            'pestilence':               'dcss/boss/horseman_pestilence.png',
            'kirgan the destroyer':     'dcss/boss/kirgan.png',
            'shadow lord malachar':     'dcss/boss/shadow_lord.png',
            'goblin king grizznak':     'dcss/boss/goblin_king.png',
            'the goblin king':          'dcss/boss/goblin_king.png',
            'puff':                     'dcss/dragons/golden_dragon.png',
            'aurexus the bronze dragon':'dcss/dragons/golden_dragon.png',
            'kaleidos the prismatic dragon': 'dcss/dragons/golden_dragon.png',
            'scorathax the red dragon': 'dcss/dragons/fire_dragon.png',
            'verdraxx the green dragon':'dcss/dragons/shadow_dragon.png',
            'vyrkothas the frost wyrm': 'dcss/dragons/ice_dragon.png',
            'yevaud':                   'dcss/dragons/fire_dragon.png',
            'sage aldric':              'dcss/holy/daeva.png',
        };

        function getDCSSPortraitSprite(mob, mobType) {
            const name = (mob.name || '').toLowerCase();
            // 1. Exact name match first (single-word bosses / named NPCs to avoid partial bleed)
            if (DCSS_EXACT_NAME_MAP[name]) return '/sprites/' + DCSS_EXACT_NAME_MAP[name];
            // 2. Keyword partial match
            for (const [keyword, path] of DCSS_NAME_MAP) {
                if (name.includes(keyword)) return '/sprites/' + path;
            }
            // 3. Type fallback
            return '/sprites/' + (DCSS_TYPE_FALLBACK[mobType] || 'mob_humanoid.png');
        }

        // Combat portrait state
        let currentEnemy = null;

        // Track mob death state by name (cleared when leaving room)
        const deadMobNames = new Set();

        function markMobDead(name) {
            if (name) deadMobNames.add(name.toLowerCase());
            // Reflect in portrait if this was the current enemy
            if (currentEnemy && currentEnemy.name &&
                deadMobNames.has(currentEnemy.name.toLowerCase())) {
                _applyDeadPortraitState();
            }
        }

        function _applyDeadPortraitState() {
            const imgEl = document.getElementById('portrait-img');
            const overlay = document.getElementById('portrait-dead-overlay');
            const hpFill = document.getElementById('portrait-hp-fill');
            if (imgEl) imgEl.classList.add('dead');
            if (overlay) overlay.classList.add('visible');
            if (hpFill) { hpFill.style.width = '0%'; hpFill.style.background = '#333'; }
            const label = document.getElementById('portrait-hp-label');
            if (label) label.textContent = 'DEAD';
            const typeEl = document.getElementById('portrait-type');
            if (typeEl) typeEl.textContent = 'defeated';
            // Auto-hide after 3s
            setTimeout(() => {
                const portrait = document.getElementById('combat-portrait');
                if (portrait) portrait.classList.add('hidden');
            }, 3000);
        }

        function updateCombatPortrait(mob) {
            const portrait = document.getElementById('combat-portrait');
            const imgEl = document.getElementById('portrait-img');
            const emptyEl = document.getElementById('portrait-empty');
            const flagsEl = document.getElementById('portrait-flags');

            // Always visible after login
            portrait.classList.remove('hidden');

            if (!mob) {
                currentEnemy = null;
                currentTargetName = null;
                document.getElementById('portrait-frame').className = '';
                document.getElementById('portrait-name').textContent = 'No Target';
                document.getElementById('portrait-level').textContent = '';
                document.getElementById('portrait-type').textContent = '‚Äî';
                document.getElementById('portrait-hp-fill').style.width = '0%';
                document.getElementById('portrait-hp-label').textContent = '';
                if (imgEl) imgEl.style.display = 'none';
                if (emptyEl) emptyEl.style.display = 'block';
                if (flagsEl) flagsEl.innerHTML = '';
                renderPortraitGrid(currentRoom, null);
                return;
            }

            currentEnemy = mob;
            currentTargetName = mob.name || currentTargetName;
            if (imgEl) imgEl.style.display = 'block';
            if (emptyEl) emptyEl.style.display = 'none';

            const mobType = classifyMob(mob);
            const isBoss = mobType === 'boss';
            document.getElementById('portrait-frame').className = isBoss ? 'boss-frame' : '';
            document.getElementById('portrait-name').textContent = mob.name || 'Unknown';
            document.getElementById('portrait-level').textContent = mob.level ? `Level ${mob.level}` : '';
            document.getElementById('portrait-type').textContent = mobType;

            // Flags / traits
            if (flagsEl) {
                const tags = [];
                if (mob.hostile) tags.push('hostile');
                if (mob.boss) tags.push('boss');
                if (mob.shopkeeper) tags.push('shop');
                (mob.flags || []).forEach(f => {
                    const clean = (f || '').toLowerCase();
                    if (clean && !tags.includes(clean)) tags.push(clean);
                });
                flagsEl.innerHTML = tags.slice(0, 6).map(t => `<span class="flag">${t.replace(/_/g,' ')}</span>`).join('');
            }

            // Dead state check
            const isDead = mob.hp === 0 ||
                (mob.name && deadMobNames.has(mob.name.toLowerCase()));

            // Render multi-portrait grid
            renderPortraitGrid(currentRoom, mob);

            const overlay = document.getElementById('portrait-dead-overlay');
            imgEl.classList.toggle('dead', isDead);
            overlay?.classList.toggle('visible', isDead);

            // HP bar
            if (mob.hp !== undefined && mob.maxHp) {
                const pct = Math.max(0, Math.min(100, (mob.hp / mob.maxHp) * 100));
                document.getElementById('portrait-hp-fill').style.width = pct + '%';
                document.getElementById('portrait-hp-label').textContent = isDead ? 'DEAD' : `${mob.hp}/${mob.maxHp}`;
                const color = pct > 50 ? '#ff4444' : pct > 25 ? '#ff8800' : '#ff0000';
                document.getElementById('portrait-hp-fill').style.background = isDead
                    ? '#333'
                    : `linear-gradient(90deg, ${color}88, ${color})`;
            } else if (isDead) {
                document.getElementById('portrait-hp-fill').style.width = '0%';
                document.getElementById('portrait-hp-label').textContent = 'DEAD';
            } else {
                document.getElementById('portrait-hp-fill').style.width = '100%';
                document.getElementById('portrait-hp-label').textContent = '';
            }

            // Sprite image ‚Äî try DCSS name-matched first, fall back to type default
            const spriteUrl = getDCSSPortraitSprite(mob, mobType);
            imgEl.src = spriteUrl;
            imgEl.onerror = () => { imgEl.style.display = 'none'; };
            imgEl.onload = () => { imgEl.style.display = 'block'; };
        }

        function renderPortraitGrid(room, selected) {
            const grid = document.getElementById('portrait-grid');
            if (!grid) return;
            const mobs = room?.mobs || [];
            if (!mobs.length) { grid.innerHTML = ''; return; }

            const maxTiles = 8;
            const items = mobs.slice(0, maxTiles);
            const more = mobs.length - items.length;

            grid.innerHTML = items.map(mob => {
                const spriteUrl = getDCSSPortraitSprite(mob, classifyMob(mob));
                const pct = mob.hp && mob.maxHp ? Math.max(0, Math.min(100, (mob.hp/mob.maxHp)*100)) : 100;
                const active = selected && mob.name === selected.name ? 'active' : '';
                return `
                    <div class="portrait-tile ${active}" data-name="${mob.name}">
                        <img src="${spriteUrl}" onerror="this.style.display='none'"/>
                        <div class="lvl">Lv ${mob.level||'?'}</div>
                        <div class="hp"><div style="width:${pct}%"></div></div>
                    </div>
                `;
            }).join('') + (more > 0 ? `<div class="portrait-more">+${more}</div>` : '');

            // Click to target
            grid.querySelectorAll('.portrait-tile').forEach(el => {
                el.addEventListener('click', () => {
                    const name = el.getAttribute('data-name');
                    const mob = mobs.find(m => m.name === name);
                    if (mob) updateCombatPortrait(mob);
                });
            });
        }

        function updatePortraitFromRoom() {
            if (!currentRoom) { updateCombatPortrait(null); return; }
            const mobs = currentRoom.mobs || [];
            if (!mobs.length) { updateCombatPortrait(null); return; }

            // Prefer current enemy if still in room
            if (currentEnemy && mobs.find(m => m.name === currentEnemy.name)) {
                updateCombatPortrait(currentEnemy);
                return;
            }

            // Boss > hostile > first
            const boss = mobs.find(m => m.boss);
            const hostile = mobs.find(m => m.hostile);
            const target = boss || hostile || mobs[0];
            if (target) updateCombatPortrait(target);
            else updateCombatPortrait(null);
        }

        function setCombatState(fighting) {
            inCombat = fighting;
            document.getElementById('combat-indicator').classList.toggle('active', fighting);
            updatePortraitFromRoom();
        }
        
        // ============================================
        // Hotkeys
        // ============================================
        
        const HOTKEY_COOLDOWNS = {
            1: 1.5,
            2: 3,
            3: 6,
            4: 4,
            5: 4,
            6: 4,
            7: 5,
            8: 5,
            9: 6,
        };

        function startCooldown(slot) {
            const el = document.querySelector(`.hotkey-slot[data-slot="${slot}"]`);
            if (!el || el.classList.contains('on-cooldown')) return;
            const cd = HOTKEY_COOLDOWNS[slot] || 3;
            const label = el.querySelector('.cooldown');
            if (label) label.textContent = Math.ceil(cd);
            el.classList.add('on-cooldown');
            let remaining = cd;
            const tick = setInterval(() => {
                remaining -= 0.1;
                if (label) label.textContent = Math.max(0, Math.ceil(remaining));
                if (remaining <= 0) {
                    clearInterval(tick);
                    el.classList.remove('on-cooldown');
                    if (label) label.textContent = '';
                }
            }, 100);
        }

        function initHotkeyCooldowns() {
            document.querySelectorAll('.hotkey-slot').forEach(el => {
                if (!el.querySelector('.cooldown')) {
                    const c = document.createElement('span');
                    c.className = 'cooldown';
                    el.appendChild(c);
                }
            });
        }

        function useHotkey(slot) {
            const cmd = hotkeys[slot];
            if (cmd) {
                sendCommand(cmd);
                startCooldown(slot);
            }
        }
        
        // ============================================
        // Text Output
        // ============================================
        
        function triggerCombatAnimations(text) {
            if (!playerMarker) return;
            const playerSprite = playerMarker.userData.sprite;
            const playerAnim = playerSprite?.userData?.animator;

            // Parse damage number from text e.g. "[125 damage]" or "125 damage"
            const dmgMatch = text.match(/\[(\d+)\s*damage\]|(\d+)\s*damage/i);
            const dmgNum = dmgMatch ? parseInt(dmgMatch[1] || dmgMatch[2]) : null;

            // Live enemy HP from verbal descriptions
            const hpDescriptions = [
                [/is in perfect (health|condition)/i, 100],
                [/is slightly scratched/i, 92],
                [/has a few scratches/i, 85],
                [/has some small wounds/i, 75],
                [/has quite a few wounds/i, 60],
                [/has some big nasty wounds/i, 45],
                [/looks pretty hurt/i, 35],
                [/is in (poor|bad) condition/i, 25],
                [/is in critical condition/i, 12],
                [/is (almost dead|nearly dead|mortally wounded)/i, 5],
            ];
            for (const [re, pct] of hpDescriptions) {
                if (re.test(text)) {
                    const fill = document.getElementById('portrait-hp-fill');
                    const label = document.getElementById('portrait-hp-label');
                    if (fill) {
                        fill.style.width = pct + '%';
                        fill.style.background = pct > 50 ? 'linear-gradient(90deg,#cc2222,#ff4444)' :
                                                 pct > 25 ? 'linear-gradient(90deg,#cc6600,#ff8800)' :
                                                            'linear-gradient(90deg,#880000,#ff0000)';
                    }
                    if (label && currentEnemy) label.textContent = pct + '%';
                    break;
                }
            }

            // Player attacks
            if (/you (hit|slash|strike|stab|bash|smash|cast|blast|obliterate|pierce|crush)/i.test(text)) {
                if (playerAnim) playerAnim.setState('attack');
                if (currentRoom) {
                    const mesh = roomMeshes.get(currentRoom.vnum);
                    const hitType = /cast|blast|spell/i.test(text) ? 'magic' : 'slash';
                    if (mesh) spawnHitParticles(mesh.position.clone(), hitType);
                }
                if (playerMarker) {
                    const label = dmgNum ? dmgNum.toString() : (Math.floor(Math.random()*40+10)).toString();
                    spawnFloatingText(playerMarker.position.clone(), label, '#ffcc00');
                }
                if (dmgNum && dmgNum > 100) SFX.critHit(); else SFX.hit();
                if (/cast|blast|spell/i.test(text)) SFX.spell();
            }

            // Player takes damage
            if (/hits you|strikes you|claws you|bites you|slashes you|mauls you/i.test(text)) {
                if (playerAnim) playerAnim.setState('hurt');
                screenFlash('rgba(220,20,20,0.3)', 400);
                SFX.hurt();
                if (dmgNum && playerMarker) {
                    spawnFloatingText(playerMarker.position.clone(), '-' + dmgNum, '#ff4444');
                }
            }

            // Enemy dies
            if (/is dead!|is slain!/i.test(text)) {
                if (currentRoom) {
                    const mesh = roomMeshes.get(currentRoom.vnum);
                    if (mesh) {
                        mesh.children.forEach(child => {
                            const s = child.userData?.sprite;
                            if (s?.userData?.animator) s.userData.animator.setState('death');
                        });
                        spawnHitParticles(mesh.position.clone(), 'slash');
                    }
                }
                SFX.enemyDeath();
            }

            // Healing
            if (/you heal|you feel better|you are healed|recover.*hp/i.test(text)) {
                if (playerMarker) spawnFloatingText(playerMarker.position.clone(), '+HP', '#44ff88');
                screenFlash('rgba(0,200,100,0.2)', 400);
                SFX.heal();
            }

            // Level up
            if (/you gain a level|welcome to level/i.test(text)) {
                SFX.levelUp();
            }

            // Movement ‚Äî brief walk animation + footstep
            if (/^(north|south|east|west|up|down)\b/i.test(text.trim())) {
                if (playerAnim) { playerAnim.setState('walk'); setTimeout(() => playerAnim?.setState('idle'), 400); }
                SFX.step();
            }
        }

        function appendOutput(html) {
            const output = document.getElementById('text-output');
            output.innerHTML += html;
            output.scrollTop = output.scrollHeight;
            
            // Parse stats from output
            const text = html.replace(/<[^>]+>/g, '');
            parseStats(text);
            triggerCombatAnimations(text);

            // Parse combat events for VFX
            _parseCombatText(text);
        }
        
        // ============================================
        // WebSocket Connection
        // ============================================
        
        function connect() {
            const account = document.getElementById('account-name').value.trim();
            const password = document.getElementById('account-password').value;
            
            if (!account) {
                alert('Please enter your account name');
                return;
            }
            
            document.getElementById('login-panel').style.display = 'none';
            document.getElementById('top-bar').classList.remove('hidden');
            document.getElementById('minimap').classList.remove('hidden');
            document.getElementById('zoom-controls').classList.remove('hidden');
            document.getElementById('map-view-controls').classList.remove('hidden');
            document.getElementById('hotkey-bar').classList.remove('hidden');
            initHotkeyCooldowns();
            document.getElementById('controls-help').classList.remove('hidden');
            document.getElementById('text-panel').classList.remove('hidden');
            document.getElementById('combat-panel').classList.remove('hidden');
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname || 'localhost';
            
            mudWs = new WebSocket(`${protocol}//${host}:${CONFIG.MUD_PORT}/ws`);
            
            mudWs.onopen = () => {
                appendOutput('<span style="color:#4ade80">Connected to RealmsMUD</span><br>');
                setTimeout(() => {
                    mudWs.send(JSON.stringify({ type: 'input', data: account }));
                    setTimeout(() => {
                        mudWs.send(JSON.stringify({ type: 'input', data: password }));
                    }, 500);
                }, 500);
            };
            
            mudWs.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'output') {
                        appendOutput(data.data);
                        
                        const text = data.data.replace(/<[^>]+>/g, '');
                        if (text.includes('Welcome') || text.includes('MOTD')) {
                            onLoggedIn();
                        }
                    }
                    if (data.type === 'mapsync') {
                        playerName = data.player;
                        connectMapSocket();
                    }
                } catch (e) {
                    appendOutput(event.data);
                }
            };
            
            mudWs.onclose = () => {
                appendOutput('<br><span style="color:#ef4444">Disconnected</span><br>');
            };
        }
        
        function onLoggedIn() {
            isLoggedIn = true;
            document.getElementById('command-input').focus();
        }
        
        function connectMapSocket() {
            if (mapWs) return;
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname || 'localhost';
            
            mapWs = new WebSocket(`${protocol}//${host}:${CONFIG.MAP_PORT}`);
            
            mapWs.onopen = () => {
                mapWs.send(JSON.stringify({ type: 'subscribe', player: playerName, mode: 'full' }));
            };
            
            mapWs.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'map_data') {
                        renderMap(data);
                        // Store full player data for character sheet
                        if (data.player) {
                            playerData = data.player;
                            updateStatusEffects(playerData);
                            const panel = document.getElementById('char-sheet');
                            if (panel && !panel.classList.contains('hidden')) {
                                renderCharacterSheet(playerData);
                            }
                        }
                    }
                } catch (e) {}
            };
            
            mapWs.onclose = () => {
                mapWs = null;
                setTimeout(() => {
                    if (playerName) connectMapSocket();
                }, 2000);
            };
        }
        
        function sendCommand(cmd) {
            if (mudWs && mudWs.readyState === WebSocket.OPEN) {
                mudWs.send(JSON.stringify({ type: 'input', data: cmd }));
                if (cmd.trim() && (commandHistory.length === 0 || commandHistory[commandHistory.length-1] !== cmd)) {
                    commandHistory.push(cmd);
                    if (commandHistory.length > 100) commandHistory.shift();
                }
                historyIndex = commandHistory.length;
            }
        }
        
        function sendCurrentCommand() {
            const input = document.getElementById('command-input');
            const cmd = input.value.trim();
            if (cmd) {
                sendCommand(cmd);
                input.value = '';
            }
        }
        
        // ============================================
        // Keyboard Input
        // ============================================
        
        document.addEventListener('DOMContentLoaded', () => {
            const cmdInput = document.getElementById('command-input');
            
            cmdInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendCurrentCommand();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        cmdInput.value = commandHistory[historyIndex] || '';
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        cmdInput.value = commandHistory[historyIndex] || '';
                    } else {
                        historyIndex = commandHistory.length;
                        cmdInput.value = '';
                    }
                }
            });
        });
        
        document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT') return;
            if (document.getElementById('login-panel').style.display !== 'none') return;
            
            // Movement keys
            const moveMap = {
                'ArrowUp': 'north', 'ArrowDown': 'south',
                'ArrowRight': 'east', 'ArrowLeft': 'west',
                'PageUp': 'up', 'PageDown': 'down',
            };
            
            if (moveMap[e.key]) {
                e.preventDefault();
                clearPath(); // Cancel autowalk
                sendCommand(moveMap[e.key]);
                return;
            }
            
            // Hotkeys 1-9
            if (e.key >= '1' && e.key <= '9') {
                e.preventDefault();
                useHotkey(parseInt(e.key));
                return;
            }

            // Tab target cycle (Shift+Tab for reverse)
            if (e.key === 'Tab') {
                e.preventDefault();
                cycleTarget(e.shiftKey ? -1 : 1);
                return;
            }
            
            // Escape cancels autowalk / closes world map
            if (e.key === 'Escape') {
                clearPath();
                closeWorldMap();
            }
            // C key toggles character sheet
            if (e.key === 'c' || e.key === 'C') {
                e.preventDefault();
                toggleCharSheet();
            }
            // M key opens world map
            if (e.key === 'm' || e.key === 'M') {
                e.preventDefault();
                const overlay = document.getElementById('world-map-overlay');
                if (overlay.classList.contains('hidden')) openWorldMap();
                else closeWorldMap();
            }
            // N key toggles minimap size
            if (e.key === 'n' || e.key === 'N') {
                e.preventDefault();
                toggleMinimap();
            }
        });
        
        // Login form handlers
        document.getElementById('account-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('account-password').focus();
        });
        
        document.getElementById('account-password').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') connect();
        });
        
        // ============================================
        // ============================================
        // Sound System (Web Audio API ‚Äî no files needed)
        // ============================================

        let audioCtx = null;
        let soundEnabled = true;

        function getAudioCtx() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            return audioCtx;
        }

        function playTone(freq, type, duration, volume = 0.15, fadeOut = true) {
            if (!soundEnabled) return;
            try {
                const ctx = getAudioCtx();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = type;
                osc.frequency.setValueAtTime(freq, ctx.currentTime);
                gain.gain.setValueAtTime(volume, ctx.currentTime);
                if (fadeOut) gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + duration);
            } catch(e) {}
        }

        function playNoise(duration, volume = 0.05) {
            if (!soundEnabled) return;
            try {
                const ctx = getAudioCtx();
                const bufferSize = ctx.sampleRate * duration;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(volume, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                source.connect(gain);
                gain.connect(ctx.destination);
                source.start();
            } catch(e) {}
        }

        const SFX = {
            // Combat hits
            hit() {
                playTone(180, 'sawtooth', 0.08, 0.12);
                playNoise(0.06, 0.04);
            },
            critHit() {
                playTone(220, 'sawtooth', 0.05, 0.18);
                playTone(440, 'square', 0.1, 0.1);
                playNoise(0.08, 0.06);
            },
            // Player takes damage
            hurt() {
                playTone(120, 'sawtooth', 0.15, 0.15);
                playNoise(0.1, 0.05);
            },
            // Enemy death
            enemyDeath() {
                playTone(300, 'sawtooth', 0.05, 0.1);
                playTone(150, 'sawtooth', 0.2, 0.12);
                playNoise(0.15, 0.04);
            },
            // Movement footstep
            step() {
                playNoise(0.04, 0.02);
                playTone(80, 'sine', 0.04, 0.05);
            },
            // Level up ‚Äî triumphant chord
            levelUp() {
                [523, 659, 784, 1047].forEach((f, i) => {
                    setTimeout(() => playTone(f, 'triangle', 0.4, 0.12), i * 80);
                });
            },
            // Heal
            heal() {
                [523, 659, 784].forEach((f, i) => {
                    setTimeout(() => playTone(f, 'sine', 0.3, 0.08), i * 60);
                });
            },
            // Spell cast
            spell() {
                playTone(880, 'sine', 0.1, 0.1);
                playTone(1100, 'sine', 0.2, 0.08);
                playNoise(0.1, 0.02);
            },
            // UI click / move confirm
            click() {
                playTone(600, 'sine', 0.05, 0.05);
            },
            // Boss enters room
            bossWarning() {
                playTone(110, 'sawtooth', 0.6, 0.2);
                setTimeout(() => playTone(90, 'sawtooth', 0.8, 0.25), 300);
            },
            // Ambient dungeon drip (random, quiet)
            drip() {
                playTone(800 + Math.random() * 400, 'sine', 0.05, 0.02);
            },
        };

        // Ambient sound loop by sector
        let ambientInterval = null;
        let lastSector = null;

        function startAmbientSound(sector) {
            if (sector === lastSector) return;
            lastSector = sector;
            if (ambientInterval) clearInterval(ambientInterval);

            if (sector === 'dungeon' || sector === 'cave') {
                ambientInterval = setInterval(() => {
                    if (Math.random() < 0.3) SFX.drip();
                }, 3000);
            } else if (sector?.includes('water')) {
                ambientInterval = setInterval(() => {
                    if (Math.random() < 0.4) playTone(200 + Math.random() * 100, 'sine', 0.1, 0.03);
                }, 2000);
            } else {
                ambientInterval = null;
            }
        }

        // Add sound toggle button to zoom controls
        document.addEventListener('DOMContentLoaded', () => {
            const zoomControls = document.getElementById('zoom-controls');
            if (zoomControls) {
                const btn = document.createElement('button');
                btn.className = 'zoom-btn';
                btn.id = 'sound-btn';
                btn.title = 'Toggle sound';
                btn.textContent = 'üîä';
                btn.onclick = () => {
                    soundEnabled = !soundEnabled;
                    btn.textContent = soundEnabled ? 'üîä' : 'üîá';
                };
                zoomControls.appendChild(btn);

                // Character sheet toggle button
                const csBtn = document.createElement('button');
                csBtn.className = 'zoom-btn';
                csBtn.id = 'cs-btn';
                csBtn.title = 'Character Sheet (C)';
                csBtn.textContent = 'üìã';
                csBtn.onclick = toggleCharSheet;
                zoomControls.appendChild(csBtn);
            }
        });

        // ============================================
        // Character Sheet
        // ============================================

        let playerData = null;
        let csActiveTab = 'stats';

        function toggleCharSheet() {
            const panel = document.getElementById('char-sheet');
            if (!panel) return;
            panel.classList.toggle('hidden');
            if (!panel.classList.contains('hidden') && playerData) {
                renderCharacterSheet(playerData);
            }
        }

        function switchCSTab(tab, btn) {
            csActiveTab = tab;
            document.querySelectorAll('.cs-tab').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            if (playerData) renderCharacterSheet(playerData);
        }

        // ‚îÄ‚îÄ‚îÄ Gear Tier Detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function getGearTier(p) {
            const body = p.equipment && p.equipment.body;
            if (!body) return 'naked';
            const name = (body.name || '').toLowerCase();
            // Plate / heavy armor keywords
            if (/\b(plate|platemail|full[\s-]?plate|breastplate|cuirass|hauberk of|lorica|mithril|adamant|dragonscale|obsidian|infernal|titanium|fortress|mail of|iron chest|steel chest)\b/.test(name)) return 'plate';
            // Chain / medium armor keywords
            if (/\b(chain|chainmail|chain[\s-]?mail|ring[\s-]?mail|scale[\s-]?mail|scale armor|hauberk|brigandine|coat of plates|lamellar)\b/.test(name)) return 'chain';
            // Leather / light armor keywords
            if (/\b(leather|hide|studded|padded|soft[\s-]?armor|fur|jerkin|vest|cuir|gambeson|quilted|cloth)\b/.test(name)) return 'leather';
            // Robe / caster / clothing keywords (leather tier)
            if (/\b(robe|vestment|cassock|cloak|habit|wrap|shroud|shirt|tunic|jacket|coat|doublet|surcoat|apron|dress|gown)\b/.test(name)) return 'leather';
            // Fallback: any body armor is at least leather tier
            return (body.armor && body.armor >= 3) ? 'chain' : 'leather';
        }

        // ‚îÄ‚îÄ‚îÄ Gear-aware portrait path ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function getPlayerPortrait(p) {
            const cls = (p.char_class || '').toLowerCase();
            const tier = getGearTier(p);
            return `/sprites/players/${cls}_${tier}.png`;
        }

        function renderCharacterSheet(p) {
            if (!p) return;

            // Header
            const cls = (p.char_class || '').toLowerCase();
            const portrait = document.getElementById('cs-portrait');
            if (portrait) {
                const tierSrc = getPlayerPortrait(p);
                portrait.src = tierSrc;
                // Fallback chain: tier portrait ‚Üí old class sprite ‚Üí hidden
                portrait.onerror = () => {
                    if (portrait.src.includes('/players/')) {
                        portrait.src = `/sprites/${cls}.png`;
                        portrait.onerror = () => { portrait.style.display='none'; };
                    } else {
                        portrait.style.display='none';
                    }
                };
                portrait.onload = () => { portrait.style.display='block'; };
            }
            const nameEl = document.getElementById('cs-name');
            if (nameEl) nameEl.textContent = p.name || '‚Äî';
            const badgeEl = document.getElementById('cs-class-badge');
            if (badgeEl) badgeEl.textContent = `Lv${p.level||1} ${cls} ${p.race||''}`.trim();

            const content = document.getElementById('cs-content');
            if (!content) return;

            if (csActiveTab === 'stats') {
                const hpPct  = Math.max(0, Math.min(100, (p.hp  / (p.max_hp  || 1)) * 100));
                const mpPct  = Math.max(0, Math.min(100, (p.mana/ (p.max_mana|| 1)) * 100));
                const mvPct  = Math.max(0, Math.min(100, (p.move/ (p.max_move|| 1)) * 100));
                content.innerHTML = `
                  <div class="cs-stat-bars">
                    <div class="cs-bar-row"><span class="cs-bar-label">HP</span><div class="cs-bar-wrap"><div class="cs-bar-fill" style="width:${hpPct}%;background:linear-gradient(90deg,#cc2222,#ff4444)"></div></div><span class="cs-bar-val">${p.hp||0}/${p.max_hp||0}</span></div>
                    <div class="cs-bar-row"><span class="cs-bar-label">MP</span><div class="cs-bar-wrap"><div class="cs-bar-fill" style="width:${mpPct}%;background:linear-gradient(90deg,#2244cc,#4488ff)"></div></div><span class="cs-bar-val">${p.mana||0}/${p.max_mana||0}</span></div>
                    <div class="cs-bar-row"><span class="cs-bar-label">MV</span><div class="cs-bar-wrap"><div class="cs-bar-fill" style="width:${mvPct}%;background:linear-gradient(90deg,#228822,#44cc44)"></div></div><span class="cs-bar-val">${p.move||0}/${p.max_move||0}</span></div>
                  </div>
                  <div class="cs-stats-grid">
                    <div class="cs-stat-cell"><span class="cs-stat-name">STR</span><span class="cs-stat-val">${p.str||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">DEX</span><span class="cs-stat-val">${p.dex||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">CON</span><span class="cs-stat-val">${p.con||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">INT</span><span class="cs-stat-val">${p.int||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">WIS</span><span class="cs-stat-val">${p.wis||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">CHA</span><span class="cs-stat-val">${p.cha||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">Hit</span><span class="cs-stat-val">${p.hitroll||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">Dam</span><span class="cs-stat-val">${p.damroll||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">AC</span><span class="cs-stat-val">${p.armor_class||0}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">Gold</span><span class="cs-stat-val">${(p.gold||0).toLocaleString()}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">Exp</span><span class="cs-stat-val">${(p.exp||0).toLocaleString()}</span></div>
                    <div class="cs-stat-cell"><span class="cs-stat-name">Level</span><span class="cs-stat-val">${p.level||1}</span></div>
                  </div>
                  ${p.title ? `<div style="color:#888;font-size:10px;text-align:center;margin-top:4px;font-style:italic">${p.title}</div>` : ''}
                `;
            } else if (csActiveTab === 'equip') {
                const EQ_ORDER = ['wield','hold','head','body','about','hands','waist','feet','neck1','neck2','finger1','finger2','wrist1','wrist2','back','arms','shoulders','face','ears','shield'];
                const eq = p.equipment || {};
                const rows = EQ_ORDER.filter(s => eq[s]).map(slot => {
                    const item = eq[slot];
                    const affects = (item.affects||[]).map(a => {
                        const sign = a.value >= 0 ? '+' : '';
                        return `${sign}${a.value} ${(a.type||'').replace(/_/g,' ')}`;
                    }).join('  ');
                    return `<div class="cs-eq-item">
                        <div class="cs-eq-slot">${slot}</div>
                        <div class="cs-eq-name">${item.name||'?'}</div>
                        ${affects ? `<div class="cs-eq-affects">${affects}</div>` : ''}
                    </div>`;
                }).join('');
                content.innerHTML = rows || '<div class="cs-empty">No equipment</div>';
            } else if (csActiveTab === 'inv') {
                const inv = p.inventory || [];
                if (!inv.length) {
                    content.innerHTML = '<div class="cs-empty">Inventory is empty</div>';
                } else {
                    content.innerHTML = inv.map(item =>
                        `<div class="cs-inv-item">${item.name||'?'}<span class="cs-inv-type">${(item.item_type||'').replace(/_/g,' ')}</span></div>`
                    ).join('');
                }
            } else if (csActiveTab === 'skills') {
                const skills  = p.skills  || {};
                const talents = p.talents || {};
                const allowed = new Set((p.class_skills || []).map(s => s.toLowerCase()));
                const fmtName = n => n.replace(/_/g,' ').replace(/\b\w/g, c => c.toUpperCase());
                const skillRows = Object.entries(skills)
                    .filter(([k,v]) => v > 0 && (allowed.size === 0 || allowed.has(k.toLowerCase())))
                    .sort((a,b)=>a[0].localeCompare(b[0]))
                    .map(([k,v]) => `<div class="cs-skill-row"><span class="cs-skill-name">${fmtName(k)}</span><span class="cs-skill-val">${v}%</span></div>`)
                    .join('');
                const talentRows = Object.entries(talents).sort((a,b)=>a[0].localeCompare(b[0])).map(([k,v]) =>
                    `<div class="cs-skill-row"><span class="cs-skill-name">${fmtName(k)}</span><span class="cs-skill-val" style="color:#ffcc44">‚òÖ${v}</span></div>`
                ).join('');
                content.innerHTML = `
                  ${skillRows  ? `<div class="cs-section-title">Skills</div><div class="cs-skill-grid">${skillRows}</div>` : ''}
                  ${talentRows ? `<div class="cs-section-title">Talents</div><div class="cs-skill-grid">${talentRows}</div>` : ''}
                  ${!skillRows && !talentRows ? '<div class="cs-empty">No skills</div>' : ''}
                `;
            }
        }

        // ============================================
        // World Map
        // ============================================

        // Fixed geographical positions (px at 900√ó620 canvas)
        // Midgaard = center hub. World expands N/S/E/W from there.
        // px = [x, y] where (0,0) = top-left
        const ZONE_POS = {
            // ‚îÄ‚îÄ MIDGAARD CORE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            30:  [450, 300],   // Midgaard (center)
            186: [510, 330],   // Newbie Zone (east of midgaard)
            260: [390, 330],   // Housing District (west of midgaard)
            12:  [450, 240],   // God Simplex (above midgaard)
            36:  [560, 280],   // Chessboard (east)
            200: [340, 280],   // Forest of Shadows (west)

            // ‚îÄ‚îÄ SOUTH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            31:  [450, 380],   // South Midgaard
            32:  [370, 400],   // Midgaard Stables
            79:  [450, 455],   // Redferne's Residence
            9:   [310, 430],   // River Island of Minos

            // ‚îÄ‚îÄ SOUTHWEST / MIDEN'NIR CLUSTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            35:  [370, 360],   // Miden'Nir
            33:  [290, 390],   // Three of Swords
            150: [310, 460],   // King Welmar's Castle
            65:  [310, 320],   // Dwarven Kingdom
            100: [240, 370],   // Dwarven Mines

            // ‚îÄ‚îÄ WEST / HAON-DOR FORESTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            60:  [270, 280],   // Haon-Dor Light Forest
            110: [200, 310],   // Silversong Elven Village
            61:  [200, 240],   // Haon-Dor Dark Forest
            62:  [130, 200],   // Orc Enclave
            63:  [150, 270],   // Arachnos

            // ‚îÄ‚îÄ NORTH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            180: [380, 195],   // Great Northern Forest
            190: [320, 140],   // Frostspire (far north)
            66:  [470, 185],   // Northern Wilderness
            235: [470, 120],   // Goblin Warrens (north)

            // ‚îÄ‚îÄ NORTHEAST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            67:  [570, 145],   // Eastern Highlands
            238: [650, 115],   // Haunted Monastery
            245: [620, 175],   // Shadowspire Citadel
            68:  [720, 160],   // Sunken Coast
            240: [780, 195],   // Sunken Temple
            69:  [800, 240],   // Ashlands
            248: [840, 285],   // Clockwork Foundry

            // ‚îÄ‚îÄ NORTHWEST / MORIA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            25:  [390, 225],   // High Tower of Magic
            40:  [440, 250],   // Mines of Moria (center-north)
            90:  [370, 255],   // Haunted Swamp
            64:  [500, 210],   // Rand's Tower

            // ‚îÄ‚îÄ EAST / TUNNEL ‚Üí APOCALYPSE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            210: [660, 265],   // Tunnel of Sticks
            220: [790, 270],   // Castle Apocalypse (far east endgame)

            // ‚îÄ‚îÄ EAST / NEW THALOS CLUSTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            54:  [620, 340],   // New Thalos (major eastern hub)
            15:  [700, 390],   // The Straight Path

            // ‚îÄ‚îÄ EAST / DESERT CLUSTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            50:  [700, 440],   // Great Eastern Desert
            51:  [760, 480],   // Drow City
            52:  [790, 415],   // City of Thalos
            53:  [750, 540],   // Great Pyramid
            120: [840, 380],   // Rome
            130: [620, 415],   // Sunken Ruins
            80:  [800, 490],   // Dragon's Domain
            160: [840, 540],   // Plane of Eternal Chaos

            // ‚îÄ‚îÄ SEWERS (below midgaard) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            70:  [480, 420],   // Sewers Level 1
            140: [420, 460],   // Necropolis
            71:  [510, 480],   // Sewers Level 2
            72:  [540, 535],   // Sewer Maze
            73:  [570, 585],   // Mindflayer's Lair

            // ‚îÄ‚îÄ MISC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            250: [720, 560],   // Blood Pit Arena
        };

        const WORLD_ZONES = [
            {id:9,   name:"River Island of Minos",      rooms:24,  level:[1,10],   connects:[31,61]},
            {id:12,  name:"God Simplex",                 rooms:7,   level:[1,5],    connects:[30]},
            {id:15,  name:"The Straight Path",           rooms:41,  level:[5,15],   connects:[54]},
            {id:25,  name:"High Tower of Magic",         rooms:183, level:[10,25],  connects:[30,40]},
            {id:30,  name:"Midgaard",                    rooms:75,  level:[1,10],   connects:[12,25,31,35,36,54,60,65,66,70,130,180,186,200,260]},
            {id:31,  name:"South Midgaard",              rooms:54,  level:[1,8],    connects:[9,30,32,35,50,79]},
            {id:32,  name:"Stables",                     rooms:4,   level:[1,5],    connects:[31]},
            {id:33,  name:"Three of Swords",             rooms:76,  level:[8,15],   connects:[35]},
            {id:35,  name:"Miden'Nir",                   rooms:45,  level:[5,12],   connects:[30,31,33,40,65,150]},
            {id:36,  name:"Chessboard",                  rooms:67,  level:[5,15],   connects:[30]},
            {id:40,  name:"Mines of Moria",              rooms:103, level:[12,20],  connects:[25,35,54,64,90,210]},
            {id:50,  name:"Eastern Desert",              rooms:74,  level:[15,25],  connects:[31,51,52,53,54,80,100,120,130]},
            {id:51,  name:"Drow City",                   rooms:51,  level:[20,30],  connects:[50]},
            {id:52,  name:"City of Thalos",              rooms:51,  level:[15,22],  connects:[50]},
            {id:53,  name:"Great Pyramid",               rooms:61,  level:[18,28],  connects:[50]},
            {id:54,  name:"New Thalos",                  rooms:285, level:[10,20],  connects:[15,40,50]},
            {id:60,  name:"Haon-Dor Light Forest",       rooms:64,  level:[8,15],   connects:[30,61,110]},
            {id:61,  name:"Haon-Dor Dark Forest",        rooms:48,  level:[12,20],  connects:[9,60,62,63]},
            {id:62,  name:"Orc Enclave",                 rooms:68,  level:[15,22],  connects:[61]},
            {id:63,  name:"Arachnos",                    rooms:52,  level:[18,25],  connects:[61]},
            {id:64,  name:"Rand's Tower",                rooms:46,  level:[20,28],  connects:[40]},
            {id:65,  name:"Dwarven Kingdom",             rooms:51,  level:[18,25],  connects:[35,100]},
            {id:66,  name:"Northern Wilderness",         rooms:14,  level:[20,30],  connects:[30,67,235]},
            {id:67,  name:"Eastern Highlands",           rooms:14,  level:[25,35],  connects:[66,68,238,245]},
            {id:68,  name:"Sunken Coast",                rooms:12,  level:[28,38],  connects:[67,69,240]},
            {id:69,  name:"Ashlands",                    rooms:12,  level:[30,40],  connects:[68,248]},
            {id:70,  name:"Sewers Lv 1",                 rooms:67,  level:[8,15],   connects:[30,71,140]},
            {id:71,  name:"Sewers Lv 2",                 rooms:26,  level:[12,18],  connects:[70,72]},
            {id:72,  name:"Sewer Maze",                  rooms:87,  level:[15,22],  connects:[71,73]},
            {id:73,  name:"Mindflayer's Lair",           rooms:3,   level:[20,28],  connects:[72]},
            {id:79,  name:"Redferne's",                  rooms:20,  level:[10,18],  connects:[31]},
            {id:80,  name:"Dragon's Domain",             rooms:5,   level:[35,50],  connects:[50,160]},
            {id:90,  name:"Haunted Swamp",               rooms:20,  level:[8,12],   connects:[40]},
            {id:100, name:"Dwarven Mines",               rooms:25,  level:[10,15],  connects:[65,50]},
            {id:110, name:"Silversong Village",          rooms:15,  level:[12,18],  connects:[60]},
            {id:120, name:"Rome",                        rooms:66,  level:[1,60],   connects:[50]},
            {id:130, name:"Sunken Ruins",                rooms:18,  level:[18,25],  connects:[30,50]},
            {id:140, name:"Necropolis",                  rooms:31,  level:[20,28],  connects:[70]},
            {id:150, name:"Welmar's Castle",             rooms:75,  level:[20,30],  connects:[35]},
            {id:160, name:"Plane of Chaos",              rooms:26,  level:[30,40],  connects:[80]},
            {id:180, name:"Northern Forest",             rooms:26,  level:[15,25],  connects:[30,190]},
            {id:186, name:"Newbie Zone",                 rooms:41,  level:[1,5],    connects:[30]},
            {id:190, name:"The Frostspire",              rooms:27,  level:[25,35],  connects:[180]},
            {id:200, name:"Forest of Shadows",           rooms:10,  level:[20,28],  connects:[30]},
            {id:210, name:"Tunnel of Sticks",            rooms:400, level:[30,45],  connects:[40,220]},
            {id:220, name:"Castle Apocalypse",           rooms:77,  level:[50,60],  connects:[210]},
            {id:235, name:"Goblin Warrens",              rooms:20,  level:[20,28],  connects:[66]},
            {id:238, name:"Haunted Monastery",           rooms:25,  level:[25,35],  connects:[67]},
            {id:240, name:"Sunken Temple",               rooms:25,  level:[28,38],  connects:[68]},
            {id:245, name:"Shadowspire Citadel",         rooms:30,  level:[30,40],  connects:[67]},
            {id:248, name:"Clockwork Foundry",           rooms:30,  level:[35,45],  connects:[69]},
            {id:250, name:"Blood Pit Arena",             rooms:7,   level:[40,60],  connects:[]},
            {id:260, name:"Housing District",            rooms:22,  level:[1,60],   connects:[30]},
        ];

        // Level-range color scale
        function zoneColor(level, alpha=1) {
            const avg = (level[0] + level[1]) / 2;
            if (avg <= 10)  return `rgba(80,200,120,${alpha})`;   // green - newbie
            if (avg <= 20)  return `rgba(100,180,220,${alpha})`;  // blue - easy
            if (avg <= 35)  return `rgba(220,180,60,${alpha})`;   // yellow - mid
            if (avg <= 50)  return `rgba(220,100,60,${alpha})`;   // orange - hard
            return `rgba(200,50,50,${alpha})`;                    // red - endgame
        }

        let wmNodes = null; // computed layout

        function buildWorldMapLayout(W, H) {
            // Fixed geographical positions scaled to canvas size
            // Base design is for 900√ó620 ‚Äî scale proportionally
            const scaleX = W / 900, scaleY = H / 620;
            return WORLD_ZONES.map(z => {
                const pos = ZONE_POS[z.id] || [450, 310]; // fallback to center
                return {
                    ...z,
                    x: pos[0] * scaleX,
                    y: pos[1] * scaleY,
                };
            });
        }

        function openWorldMap() {
            wmNodes = null; // always rebuild on open (in case canvas resized)
            document.getElementById('world-map-overlay').classList.remove('hidden');
            drawWorldMap();
        }

        function closeWorldMap() {
            document.getElementById('world-map-overlay').classList.add('hidden');
        }

        function drawWorldMap() {
            const canvas = document.getElementById('world-map-canvas');
            const W = canvas.width, H = canvas.height;
            if (!wmNodes) wmNodes = buildWorldMapLayout(W, H);

            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#080303';
            ctx.fillRect(0, 0, W, H);

            // Draw faint grid
            ctx.strokeStyle = 'rgba(60,20,20,0.3)';
            ctx.lineWidth = 1;
            for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
            for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

            const idxMap = {};
            wmNodes.forEach((n,i) => idxMap[n.id] = i);

            // Draw edges first
            wmNodes.forEach(n => {
                n.connects.forEach(cid => {
                    const m = wmNodes[idxMap[cid]];
                    if (!m || m.id < n.id) return; // draw once
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y);
                    ctx.lineTo(m.x, m.y);
                    ctx.strokeStyle = 'rgba(120,50,50,0.45)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                });
            });

            // Highlight current zone
            const currentZoneId = currentPlayerZone;

            // Draw nodes
            wmNodes.forEach(n => {
                const r = Math.max(6, Math.min(18, 4 + n.rooms / 20));
                const isCurrent = n.id === currentZoneId;

                // Glow for current
                if (isCurrent) {
                    const grd = ctx.createRadialGradient(n.x, n.y, r, n.x, n.y, r*2.5);
                    grd.addColorStop(0, 'rgba(255,220,80,0.5)');
                    grd.addColorStop(1, 'rgba(255,220,80,0)');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, r*2.5, 0, Math.PI*2);
                    ctx.fill();
                }

                // Node circle
                const isIsolated = n.connects.length === 0;
                ctx.beginPath();
                ctx.arc(n.x, n.y, r, 0, Math.PI*2);
                ctx.fillStyle = isCurrent ? '#ffd700' : zoneColor(n.level, isIsolated ? 0.5 : 0.85);
                ctx.fill();
                if (isIsolated) {
                    // Dashed border for isolated zones
                    ctx.setLineDash([3, 3]);
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.setLineDash([]);
                    ctx.strokeStyle = isCurrent ? '#fff' : 'rgba(255,255,255,0.15)';
                    ctx.lineWidth = isCurrent ? 2 : 1;
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Label ‚Äî place above or below based on y position to reduce overlap
                const labelY = n.y > H * 0.7 ? n.y - r - 10 : n.y + r + 2;
                const labelBaseline = n.y > H * 0.7 ? 'bottom' : 'top';
                ctx.fillStyle = isCurrent ? '#ffd700' : 'rgba(210,210,210,0.9)';
                ctx.font = `${isCurrent ? 'bold ' : ''}10px "Courier New"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = labelBaseline;
                // Draw subtle text shadow for legibility
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillText(n.name, n.x + 1, labelY + 1);
                ctx.fillStyle = isCurrent ? '#ffd700' : 'rgba(210,210,210,0.9)';
                ctx.fillText(n.name, n.x, labelY);
            });

            // Legend dots
            const legendData = [
                ['Lv 1-10', [1,10]], ['Lv 11-20', [11,20]], ['Lv 21-35', [21,35]], ['Lv 36-50', [36,50]], ['Lv 51-60', [51,60]]
            ];
            let lx = 16;
            legendData.forEach(([label, level]) => {
                ctx.beginPath();
                ctx.arc(lx, H-14, 5, 0, Math.PI*2);
                ctx.fillStyle = zoneColor(level, 0.9);
                ctx.fill();
                ctx.fillStyle = '#888';
                ctx.font = '9px "Courier New"';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, lx+8, H-14);
                lx += 80;
            });

            // Bind hover/click
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left) * (W / rect.width);
                const my = (e.clientY - rect.top) * (H / rect.height);
                const tip = document.getElementById('world-map-tooltip');
                let hit = null;
                wmNodes.forEach(n => {
                    const r = Math.max(6, Math.min(18, 4 + n.rooms / 20));
                    const d = Math.hypot(n.x - mx, n.y - my);
                    if (d < r + 8) hit = n;
                });
                if (hit) {
                    tip.style.display = 'block';
                    tip.style.left = (e.clientX + 14) + 'px';
                    tip.style.top = (e.clientY - 10) + 'px';
                    const access = hit.connects.length === 0 ? ' ¬∑ <i style="color:#888">Teleport access only</i>' : '';
                    tip.innerHTML = `<b>${hit.name}</b><br>Zone ${hit.id} ¬∑ ${hit.rooms} rooms ¬∑ Lv ${hit.level[0]}-${hit.level[1]}${access}`;
                    canvas.style.cursor = 'pointer';
                } else {
                    tip.style.display = 'none';
                    canvas.style.cursor = 'default';
                }
            };
            canvas.onmouseleave = () => {
                document.getElementById('world-map-tooltip').style.display = 'none';
            };
            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left) * (W / rect.width);
                const my = (e.clientY - rect.top) * (H / rect.height);
                wmNodes.forEach(n => {
                    const r = Math.max(6, Math.min(18, 4 + n.rooms / 20));
                    if (Math.hypot(n.x - mx, n.y - my) < r + 8) {
                        // Switch 3D view to this zone
                        closeWorldMap();
                        currentPlayerZone = n.id;
                        if (mapViewMode !== 'zone') setMapViewMode('zone');
                        else if (lastMapData) renderMap(lastMapData);
                    }
                });
            };
        }

        // ============================================
        // Draggable Panels
        // ============================================

        function makeDraggable(el, handleEl) {
            let dragging = false, startX, startY, origLeft, origTop, origBottom, origRight;

            handleEl.addEventListener('mousedown', e => {
                if (e.button !== 0) return;
                dragging = true;
                el.classList.add('dragging');

                const rect = el.getBoundingClientRect();
                // Convert to top/left positioning
                el.style.bottom = 'auto';
                el.style.right = 'auto';
                el.style.top = rect.top + 'px';
                el.style.left = rect.left + 'px';
                el.style.transform = 'none';

                startX = e.clientX;
                startY = e.clientY;
                origLeft = rect.left;
                origTop = rect.top;

                e.preventDefault();
            });

            document.addEventListener('mousemove', e => {
                if (!dragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                let newLeft = origLeft + dx;
                let newTop = origTop + dy;
                // Keep on screen
                newLeft = Math.max(0, Math.min(window.innerWidth - 100, newLeft));
                newTop = Math.max(0, Math.min(window.innerHeight - 60, newTop));
                el.style.left = newLeft + 'px';
                el.style.top = newTop + 'px';
            });

            document.addEventListener('mouseup', () => {
                dragging = false;
                el.classList.remove('dragging');
            });
        }

        function makeResizable(el, resizeHandle) {
            let resizing = false, startX, startY, startW, startH;
            resizeHandle.addEventListener('mousedown', e => {
                resizing = true;
                startX = e.clientX; startY = e.clientY;
                startW = el.offsetWidth; startH = el.offsetHeight;
                e.preventDefault(); e.stopPropagation();
            });
            document.addEventListener('mousemove', e => {
                if (!resizing) return;
                const w = Math.max(300, startW + (e.clientX - startX));
                const h = Math.max(120, startH + (e.clientY - startY));
                el.style.width = w + 'px';
                el.style.height = h + 'px';
            });
            document.addEventListener('mouseup', () => { resizing = false; });
        }

        // Wire up after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            // Text panel ‚Äî drag by header
            const textPanel = document.getElementById('text-panel');
            const textHeader = document.getElementById('text-panel-header');
            const textResize = document.getElementById('text-panel-resize');
            if (textPanel && textHeader) makeDraggable(textPanel, textHeader);
            if (textPanel && textResize) makeResizable(textPanel, textResize);

            // Hotkey bar ‚Äî drag anywhere on it
            const hotkeyBar = document.getElementById('hotkey-bar');
            if (hotkeyBar) {
                makeDraggable(hotkeyBar, hotkeyBar);
                // Prevent drag from triggering hotkey clicks
                hotkeyBar.addEventListener('click', e => {
                    if (hotkeyBar.classList.contains('dragging')) e.stopPropagation();
                });
            }

            // Character sheet ‚Äî drag by header
            const charSheet = document.getElementById('char-sheet');
            const csHeader = document.getElementById('cs-header');
            if (charSheet && csHeader) makeDraggable(charSheet, csHeader);

            // Combat panel ‚Äî drag by header
            const combatPanel = document.getElementById('combat-panel');
            const combatHeader = document.getElementById('combat-panel-header');
            const combatResize = document.getElementById('combat-panel-resize');
            if (combatPanel && combatHeader) makeDraggable(combatPanel, combatHeader);
            if (combatPanel && combatResize) makeResizable(combatPanel, combatResize);
        });

        // Initialize
        // ============================================
        initThree();
    </script>
</body>
</html>
